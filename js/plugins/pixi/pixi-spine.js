/*!
 * @pixi-spine/all-4.1 - v4.0.3
 * Compiled Wed, 20 Sep 2023 03:25:18 UTC
 *
 * @pixi-spine/all-4.1 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
*/this.PIXI=this.PIXI||{},this.PIXI.spine=function(F,V,Pt,Bs,Xs,ot,vt){"use strict";var Q=(r=>(r[r.Region=0]="Region",r[r.BoundingBox=1]="BoundingBox",r[r.Mesh=2]="Mesh",r[r.LinkedMesh=3]="LinkedMesh",r[r.Path=4]="Path",r[r.Point=5]="Point",r[r.Clipping=6]="Clipping",r))(Q||{});class ss{constructor(t,s=new Array,e=0,i=new DataView(t.buffer)){this.strings=s,this.index=e,this.buffer=i}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let s=this.readByte(),e=s&127;return s&128&&(s=this.readByte(),e|=(s&127)<<7,s&128&&(s=this.readByte(),e|=(s&127)<<14,s&128&&(s=this.readByte(),e|=(s&127)<<21,s&128&&(s=this.readByte(),e|=(s&127)<<28)))),t?e:e>>>1^-(e&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let s="";for(let e=0;e<t;){const i=this.readUnsignedByte();switch(i>>4){case 12:case 13:s+=String.fromCharCode((i&31)<<6|this.readByte()&63),e+=2;break;case 14:s+=String.fromCharCode((i&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),e+=3;break;default:s+=String.fromCharCode(i),e++}}return s}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var v=(r=>(r[r.setup=0]="setup",r[r.first=1]="first",r[r.replace=2]="replace",r[r.add=3]="add",r))(v||{}),et=(r=>(r[r.mixIn=0]="mixIn",r[r.mixOut=1]="mixOut",r))(et||{}),gt=(r=>(r[r.Fixed=0]="Fixed",r[r.Percent=1]="Percent",r))(gt||{}),Yt=(r=>(r[r.Tangent=0]="Tangent",r[r.Chain=1]="Chain",r[r.ChainScale=2]="ChainScale",r))(Yt||{}),nt=(r=>(r[r.Normal=0]="Normal",r[r.OnlyTranslation=1]="OnlyTranslation",r[r.NoRotationOrReflection=2]="NoRotationOrReflection",r[r.NoScale=3]="NoScale",r[r.NoScaleOrReflection=4]="NoScaleOrReflection",r))(nt||{});function he(r){switch(r.toLowerCase()){case"nearest":return st.Nearest;case"linear":return st.Linear;case"mipmap":return st.MipMap;case"mipmapnearestnearest":return st.MipMapNearestNearest;case"mipmaplinearnearest":return st.MipMapLinearNearest;case"mipmapnearestlinear":return st.MipMapNearestLinear;case"mipmaplinearlinear":return st.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${r}`)}}function Rs(r){switch(r.toLowerCase()){case"mirroredtepeat":return lt.MirroredRepeat;case"clamptoedge":return lt.ClampToEdge;case"repeat":return lt.Repeat;default:throw new Error(`Unknown texture wrap ${r}`)}}var st=(r=>(r[r.Nearest=9728]="Nearest",r[r.Linear=9729]="Linear",r[r.MipMap=9987]="MipMap",r[r.MipMapNearestNearest=9984]="MipMapNearestNearest",r[r.MipMapLinearNearest=9985]="MipMapLinearNearest",r[r.MipMapNearestLinear=9986]="MipMapNearestLinear",r[r.MipMapLinearLinear=9987]="MipMapLinearLinear",r))(st||{}),lt=(r=>(r[r.MirroredRepeat=33648]="MirroredRepeat",r[r.ClampToEdge=33071]="ClampToEdge",r[r.Repeat=10497]="Repeat",r))(lt||{});class zt{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class Ps{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class Ht{constructor(t,s,e){this.pages=new Array,this.regions=new Array,t&&this.addSpineAtlas(t,s,e)}addTexture(t,s){const e=this.pages;let i=null;for(let u=0;u<e.length;u++)if(e[u].baseTexture===s.baseTexture){i=e[u];break}if(i===null){i=new de,i.name="texturePage";const u=s.baseTexture;i.width=u.realWidth,i.height=u.realHeight,i.baseTexture=u,i.minFilter=i.magFilter=st.Nearest,i.uWrap=lt.ClampToEdge,i.vWrap=lt.ClampToEdge,e.push(i)}const a=new ue;return a.name=t,a.page=i,a.texture=s,a.index=-1,this.regions.push(a),a}addTextureHash(t,s){for(const e in t)t.hasOwnProperty(e)&&this.addTexture(s&&e.indexOf(".")!==-1?e.substr(0,e.lastIndexOf(".")):e,t[e])}addSpineAtlas(t,s,e){return this.load(t,s,e)}load(t,s,e){if(s==null)throw new Error("textureLoader cannot be null.");const i=new Ls(t),a=new Array(4);let u=null;const c={};let n=null;c.size=()=>{u.width=parseInt(a[1]),u.height=parseInt(a[2])},c.format=()=>{},c.filter=()=>{u.minFilter=he(a[1]),u.magFilter=he(a[2])},c.repeat=()=>{a[1].indexOf("x")!=-1&&(u.uWrap=lt.Repeat),a[1].indexOf("y")!=-1&&(u.vWrap=lt.Repeat)},c.pma=()=>{u.pma=a[1]=="true"};const o={};o.xy=()=>{n.x=parseInt(a[1]),n.y=parseInt(a[2])},o.size=()=>{n.width=parseInt(a[1]),n.height=parseInt(a[2])},o.bounds=()=>{n.x=parseInt(a[1]),n.y=parseInt(a[2]),n.width=parseInt(a[3]),n.height=parseInt(a[4])},o.offset=()=>{n.offsetX=parseInt(a[1]),n.offsetY=parseInt(a[2])},o.orig=()=>{n.originalWidth=parseInt(a[1]),n.originalHeight=parseInt(a[2])},o.offsets=()=>{n.offsetX=parseInt(a[1]),n.offsetY=parseInt(a[2]),n.originalWidth=parseInt(a[3]),n.originalHeight=parseInt(a[4])},o.rotate=()=>{const h=a[1];let m=0;h.toLocaleLowerCase()=="true"?m=6:h.toLocaleLowerCase()=="false"?m=0:m=(720-parseFloat(h))%360/45,n.rotate=m},o.index=()=>{n.index=parseInt(a[1])};let l=i.readLine();for(;l!=null&&l.trim().length==0;)l=i.readLine();for(;!(l==null||l.trim().length==0||i.readEntry(a,l)==0);)l=i.readLine();const d=()=>{for(;;){if(l==null)return e&&e(this);if(l.trim().length==0)u=null,l=i.readLine();else if(u===null){for(u=new de,u.name=l.trim();i.readEntry(a,l=i.readLine())!=0;){const h=c[a[0]];h&&h()}this.pages.push(u),s(u.name,h=>{if(h===null)return this.pages.splice(this.pages.indexOf(u),1),e&&e(null);u.baseTexture=h,u.pma&&(h.alphaMode=V.ALPHA_MODES.PMA),h.valid||h.setSize(u.width,u.height),u.setFilters(),(!u.width||!u.height)&&(u.width=h.realWidth,u.height=h.realHeight,(!u.width||!u.height)&&console.log(`ERROR spine atlas page ${u.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),d()});break}else{n=new Ps;const h=new ue;h.name=l,h.page=u;let m=null,f=null;for(;;){const x=i.readEntry(a,l=i.readLine());if(x==0)break;const y=o[a[0]];if(y)y();else{m==null&&(m=[],f=[]),m.push(a[0]);const k=[];for(let C=0;C<x;C++)k.push(parseInt(a[C+1]));f.push(k)}}n.originalWidth==0&&n.originalHeight==0&&(n.originalWidth=n.width,n.originalHeight=n.height);const g=u.baseTexture.resolution;n.x/=g,n.y/=g,n.width/=g,n.height/=g,n.originalWidth/=g,n.originalHeight/=g,n.offsetX/=g,n.offsetY/=g;const w=n.rotate%4!==0,S=new V.Rectangle(n.x,n.y,w?n.height:n.width,w?n.width:n.height),p=new V.Rectangle(0,0,n.originalWidth,n.originalHeight),b=new V.Rectangle(n.offsetX,n.originalHeight-n.height-n.offsetY,n.width,n.height);h.texture=new V.Texture(h.page.baseTexture,S,p,b,n.rotate),h.index=n.index,h.texture.updateUvs(),this.regions.push(h)}}};d()}findRegion(t){for(let s=0;s<this.regions.length;s++)if(this.regions[s].name==t)return this.regions[s];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class Ls{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,s){if(s==null||(s=s.trim(),s.length==0))return 0;const e=s.indexOf(":");if(e==-1)return 0;t[0]=s.substr(0,e).trim();for(let i=1,a=e+1;;i++){const u=s.indexOf(",",a);if(u==-1)return t[i]=s.substr(a).trim(),i;if(t[i]=s.substr(a,u-a).trim(),a=u+1,i==4)return 4}}}class de{constructor(){this.minFilter=st.Nearest,this.magFilter=st.Nearest,this.uWrap=lt.ClampToEdge,this.vWrap=lt.ClampToEdge}setFilters(){const t=this.baseTexture,s=this.minFilter;s==st.Linear?t.scaleMode=V.SCALE_MODES.LINEAR:this.minFilter==st.Nearest?t.scaleMode=V.SCALE_MODES.NEAREST:(t.mipmap=V.MIPMAP_MODES.POW2,s==st.MipMapNearestNearest?t.scaleMode=V.SCALE_MODES.NEAREST:t.scaleMode=V.SCALE_MODES.LINEAR)}}class ue extends zt{}class Ds{constructor(){this.array=new Array}add(t){const s=this.contains(t);return this.array[t|0]=t|0,!s}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}}class fe{constructor(){this.entries={},this.size=0}add(t){const s=this.entries[t];return this.entries[t]=!0,s?!1:(this.size++,!0)}addAll(t){const s=this.size;for(let e=0,i=t.length;e<i;e++)this.add(t[e]);return s!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const Et=class{constructor(r=0,t=0,s=0,e=0){this.r=r,this.g=t,this.b=s,this.a=e}set(r,t,s,e){return this.r=r,this.g=t,this.b=s,this.a=e,this.clamp()}setFromColor(r){return this.r=r.r,this.g=r.g,this.b=r.b,this.a=r.a,this}setFromString(r){return r=r.charAt(0)=="#"?r.substr(1):r,this.r=parseInt(r.substr(0,2),16)/255,this.g=parseInt(r.substr(2,2),16)/255,this.b=parseInt(r.substr(4,2),16)/255,this.a=r.length!=8?1:parseInt(r.substr(6,2),16)/255,this}add(r,t,s,e){return this.r+=r,this.g+=t,this.b+=s,this.a+=e,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(r,t){r.r=((t&4278190080)>>>24)/255,r.g=((t&16711680)>>>16)/255,r.b=((t&65280)>>>8)/255,r.a=(t&255)/255}static rgb888ToColor(r,t){r.r=((t&16711680)>>>16)/255,r.g=((t&65280)>>>8)/255,r.b=(t&255)/255}static fromString(r){return new Et().setFromString(r)}};let D=Et;D.WHITE=new Et(1,1,1,1),D.RED=new Et(1,0,0,1),D.GREEN=new Et(0,1,0,1),D.BLUE=new Et(0,0,1,1),D.MAGENTA=new Et(1,0,1,1);const bt=class{static clamp(r,t,s){return r<t?t:r>s?s:r}static cosDeg(r){return Math.cos(r*bt.degRad)}static sinDeg(r){return Math.sin(r*bt.degRad)}static signum(r){return Math.sign(r)}static toInt(r){return r>0?Math.floor(r):Math.ceil(r)}static cbrt(r){const t=Math.pow(Math.abs(r),.3333333333333333);return r<0?-t:t}static randomTriangular(r,t){return bt.randomTriangularWith(r,t,(r+t)*.5)}static randomTriangularWith(r,t,s){const e=Math.random(),i=t-r;return e<=(s-r)/i?r+Math.sqrt(e*i*(s-r)):t-Math.sqrt((1-e)*i*(t-s))}static isPowerOfTwo(r){return r&&(r&r-1)===0}};let E=bt;E.PI=3.1415927,E.PI2=bt.PI*2,E.radiansToDegrees=180/bt.PI,E.radDeg=bt.radiansToDegrees,E.degreesToRadians=bt.PI/180,E.degRad=bt.degreesToRadians;class ns{apply(t,s,e){return t+(s-t)*this.applyInternal(e)}}class is extends ns{constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class Ns extends is{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const Lt=class{static arrayCopy(r,t,s,e,i){for(let a=t,u=e;a<t+i;a++,u++)s[u]=r[a]}static arrayFill(r,t,s,e){for(let i=t;i<s;i++)r[i]=e}static setArraySize(r,t,s=0){const e=r.length;if(e==t)return r;if(r.length=t,e<t)for(let i=e;i<t;i++)r[i]=s;return r}static ensureArrayCapacity(r,t,s=0){return r.length>=t?r:Lt.setArraySize(r,t,s)}static newArray(r,t){const s=new Array(r);for(let e=0;e<r;e++)s[e]=t;return s}static newFloatArray(r){if(Lt.SUPPORTS_TYPED_ARRAYS)return new Float32Array(r);const t=new Array(r);for(let s=0;s<t.length;s++)t[s]=0;return t}static newShortArray(r){if(Lt.SUPPORTS_TYPED_ARRAYS)return new Int16Array(r);const t=new Array(r);for(let s=0;s<t.length;s++)t[s]=0;return t}static toFloatArray(r){return Lt.SUPPORTS_TYPED_ARRAYS?new Float32Array(r):r}static toSinglePrecision(r){return Lt.SUPPORTS_TYPED_ARRAYS?Math.fround(r):r}static webkit602BugfixHelper(r,t){}static contains(r,t,s=!0){for(let e=0;e<r.length;e++)if(r[e]==t)return!0;return!1}static enumValue(r,t){return r[t[0].toUpperCase()+t.slice(1)]}};let R=Lt;R.SUPPORTS_TYPED_ARRAYS=typeof Float32Array!="undefined";class Vs{static logBones(t){for(let s=0;s<t.bones.length;s++){const e=t.bones[s],i=e.matrix;console.log(`${e.data.name}, ${i.a}, ${i.b}, ${i.c}, ${i.d}, ${i.tx}, ${i.ty}`)}}}class me{constructor(t){this.items=new Array,this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let s=0;s<t.length;s++)this.free(t[s])}clear(){this.items.length=0}}class Gt{constructor(t=0,s=0){this.x=t,this.y=s}set(t,s){return this.x=t,this.y=s,this}length(){const t=this.x,s=this.y;return Math.sqrt(t*t+s*s)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}}class _s{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class $s{constructor(t=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let s=0;s<this.values.length;s++)t+=this.values[s];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}class ge{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new me(()=>R.newFloatArray(16))}update(t,s){if(!t)throw new Error("skeleton cannot be null.");const e=this.boundingBoxes,i=this.polygons,a=this.polygonPool,u=t.slots,c=u.length;e.length=0,a.freeAll(i),i.length=0;for(let n=0;n<c;n++){const o=u[n];if(!o.bone.active)continue;const l=o.getAttachment();if(l!=null&&l.type===Q.BoundingBox){const d=l;e.push(d);let h=a.obtain();h.length!=d.worldVerticesLength&&(h=R.newFloatArray(d.worldVerticesLength)),i.push(h),d.computeWorldVertices(o,0,d.worldVerticesLength,h,0,2)}}s?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,e=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;const a=this.polygons;for(let u=0,c=a.length;u<c;u++){const n=a[u],o=n;for(let l=0,d=n.length;l<d;l+=2){const h=o[l],m=o[l+1];t=Math.min(t,h),s=Math.min(s,m),e=Math.max(e,h),i=Math.max(i,m)}}this.minX=t,this.minY=s,this.maxX=e,this.maxY=i}aabbContainsPoint(t,s){return t>=this.minX&&t<=this.maxX&&s>=this.minY&&s<=this.maxY}aabbIntersectsSegment(t,s,e,i){const a=this.minX,u=this.minY,c=this.maxX,n=this.maxY;if(t<=a&&e<=a||s<=u&&i<=u||t>=c&&e>=c||s>=n&&i>=n)return!1;const o=(i-s)/(e-t);let l=o*(a-t)+s;if(l>u&&l<n||(l=o*(c-t)+s,l>u&&l<n))return!0;let d=(u-s)/o+t;return d>a&&d<c||(d=(n-s)/o+t,d>a&&d<c)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,s){const e=this.polygons;for(let i=0,a=e.length;i<a;i++)if(this.containsPointPolygon(e[i],t,s))return this.boundingBoxes[i];return null}containsPointPolygon(t,s,e){const i=t,a=t.length;let u=a-2,c=!1;for(let n=0;n<a;n+=2){const o=i[n+1],l=i[u+1];if(o<e&&l>=e||l<e&&o>=e){const d=i[n];d+(e-o)/(l-o)*(i[u]-d)<s&&(c=!c)}u=n}return c}intersectsSegment(t,s,e,i){const a=this.polygons;for(let u=0,c=a.length;u<c;u++)if(this.intersectsSegmentPolygon(a[u],t,s,e,i))return this.boundingBoxes[u];return null}intersectsSegmentPolygon(t,s,e,i,a){const u=t,c=t.length,n=s-i,o=e-a,l=s*a-e*i;let d=u[c-2],h=u[c-1];for(let m=0;m<c;m+=2){const f=u[m],g=u[m+1],w=d*g-h*f,S=d-f,p=h-g,b=n*p-o*S,x=(l*S-n*w)/b;if((x>=d&&x<=f||x>=f&&x<=d)&&(x>=s&&x<=i||x>=i&&x<=s)){const y=(l*p-o*w)/b;if((y>=h&&y<=g||y>=g&&y<=h)&&(y>=e&&y<=a||y>=a&&y<=e))return!0}d=f,h=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const s=this.boundingBoxes.indexOf(t);return s==-1?null:this.polygons[s]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const Mt={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},Tt=[0,0,0];class rs extends Bs.Sprite{constructor(){super(...arguments),this.region=null,this.attachment=null}}class as extends Xs.SimpleMesh{constructor(t,s,e,i,a){super(t,s,e,i,a),this.region=null,this.attachment=null}}const os=class extends Pt.Container{constructor(r){if(super(),!r)throw new Error("The spineData param is required.");if(typeof r=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=r,this.createSkeleton(r),this.slotContainers=[],this.tempClipContainers=[];for(let t=0,s=this.skeleton.slots.length;t<s;t++){const e=this.skeleton.slots[t],i=e.getAttachment(),a=this.newContainer();if(this.slotContainers.push(a),this.addChild(a),this.tempClipContainers.push(null),!!i)if(i.type===Q.Region){const u=i.name,c=this.createSprite(e,i,u);e.currentSprite=c,e.currentSpriteName=u,a.addChild(c)}else if(i.type===Q.Mesh){const u=this.createMesh(e,i);e.currentMesh=u,e.currentMeshId=i.id,e.currentMeshName=i.name,a.addChild(u)}else i.type===Q.Clipping&&(this.createGraphics(e,i),a.addChild(e.clippingContainer),a.addChild(e.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(r){var t;r!=this._debug&&((t=this._debug)==null||t.unregisterSpine(this),r==null||r.registerSpine(this),this._debug=r)}get autoUpdate(){return this._autoUpdate}set autoUpdate(r){r!==this._autoUpdate&&(this._autoUpdate=r,this.updateTransform=r?os.prototype.autoUpdateTransform:Pt.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(r){this.tintRgb=V.utils.hex2rgb(r,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Mt.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(r){var o;const t=this.delayLimit;if(r>t&&(r=t),this.state.update(r),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const s=this.skeleton.slots,e=this.color;let i=null,a=null;e?(i=e.light,a=e.dark):i=this.tintRgb;for(let l=0,d=s.length;l<d;l++){const h=s[l],m=h.getAttachment(),f=this.slotContainers[l];if(!m){f.visible=!1;continue}let g=null;m.sequence&&m.sequence.apply(h,m);let w=m.region;const S=m.color;switch(m!=null&&m.type){case Q.Region:if(f.transform.setFromMatrix(h.bone.matrix),w=m.region,h.currentMesh&&(h.currentMesh.visible=!1,h.currentMesh=null,h.currentMeshId=void 0,h.currentMeshName=void 0),!w){h.currentSprite&&(h.currentSprite.renderable=!1);break}if(!h.currentSpriteName||h.currentSpriteName!==m.name){const x=m.name;if(h.currentSprite&&(h.currentSprite.visible=!1),h.sprites=h.sprites||{},h.sprites[x]!==void 0)h.sprites[x].visible=!0;else{const y=this.createSprite(h,m,x);f.addChild(y)}h.currentSprite=h.sprites[x],h.currentSpriteName=x}h.currentSprite.renderable=!0,h.hackRegion||this.setSpriteRegion(m,h.currentSprite,w),h.currentSprite.color?g=h.currentSprite.color:(Tt[0]=i[0]*h.color.r*S.r,Tt[1]=i[1]*h.color.g*S.g,Tt[2]=i[2]*h.color.b*S.b,h.currentSprite.tint=V.utils.rgb2hex(Tt)),h.currentSprite.blendMode=h.blendMode;break;case Q.Mesh:if(h.currentSprite){h.currentSprite.visible=!1,h.currentSprite=null,h.currentSpriteName=void 0;const x=new V.Transform;x._parentID=-1,x._worldID=f.transform._worldID,f.transform=x}if(!w){h.currentMesh&&(h.currentMesh.renderable=!1);break}const b=m.id;if(h.currentMeshId===void 0||h.currentMeshId!==b){const x=b;if(h.currentMesh&&(h.currentMesh.visible=!1),h.meshes=h.meshes||{},h.meshes[x]!==void 0)h.meshes[x].visible=!0;else{const y=this.createMesh(h,m);f.addChild(y)}h.currentMesh=h.meshes[x],h.currentMeshName=m.name,h.currentMeshId=x}h.currentMesh.renderable=!0,m.computeWorldVerticesOld(h,h.currentMesh.vertices),h.currentMesh.color?g=h.currentMesh.color:(Tt[0]=i[0]*h.color.r*S.r,Tt[1]=i[1]*h.color.g*S.g,Tt[2]=i[2]*h.color.b*S.b,h.currentMesh.tint=V.utils.rgb2hex(Tt)),h.currentMesh.blendMode=h.blendMode,h.hackRegion||this.setMeshRegion(m,h.currentMesh,w);break;case Q.Clipping:h.currentGraphics||(this.createGraphics(h,m),f.addChild(h.clippingContainer),f.addChild(h.currentGraphics)),this.updateGraphics(h,m),f.alpha=1,f.visible=!0;continue;default:f.visible=!1;continue}if(f.visible=!0,g){let p=h.color.r*S.r,b=h.color.g*S.g,x=h.color.b*S.b;g.setLight(i[0]*p+a[0]*(1-p),i[1]*b+a[1]*(1-b),i[2]*x+a[2]*(1-x)),h.darkColor?(p=h.darkColor.r,b=h.darkColor.g,x=h.darkColor.b):(p=0,b=0,x=0),g.setDark(i[0]*p+a[0]*(1-p),i[1]*b+a[1]*(1-b),i[2]*x+a[2]*(1-x))}f.alpha=h.color.a}const u=this.skeleton.drawOrder;let c=null,n=null;for(let l=0,d=u.length;l<d;l++){const h=s[u[l].data.index],m=this.slotContainers[u[l].data.index];if(n||m.parent!==null&&m.parent!==this&&(m.parent.removeChild(m),m.parent=this),h.currentGraphics&&h.getAttachment())n=h.clippingContainer,c=h.getAttachment(),n.children.length=0,this.children[l]=m,c.endSlot===h.data&&(c.endSlot=null);else if(n){let f=this.tempClipContainers[l];f||(f=this.tempClipContainers[l]=this.newContainer(),f.visible=!1),this.children[l]=f,m.parent=null,n.addChild(m),c.endSlot==h.data&&(n.renderable=!0,n=null,c=null)}else this.children[l]=m}(o=this._debug)==null||o.renderDebug(this)}setSpriteRegion(r,t,s){t.attachment===r&&t.region===s||(t.region=s,t.attachment=r,t.texture=s.texture,t.rotation=r.rotation*E.degRad,t.position.x=r.x,t.position.y=r.y,t.alpha=r.color.a,s.size?(t.scale.x=s.size.width/s.originalWidth,t.scale.y=-s.size.height/s.originalHeight):(t.scale.x=r.scaleX*r.width/s.originalWidth,t.scale.y=-r.scaleY*r.height/s.originalHeight))}setMeshRegion(r,t,s){t.attachment===r&&t.region===s||(t.region=s,t.attachment=r,t.texture=s.texture,s.texture.updateUvs(),t.uvBuffer.update(r.regionUVs))}autoUpdateTransform(){if(Mt.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const r=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(r)}else this.lastTime=0;Pt.Container.prototype.updateTransform.call(this)}createSprite(r,t,s){let e=t.region;r.hackAttachment===t&&(e=r.hackRegion);const i=e?e.texture:null,a=this.newSprite(i);return a.anchor.set(.5),e&&this.setSpriteRegion(t,a,t.region),r.sprites=r.sprites||{},r.sprites[s]=a,a}createMesh(r,t){let s=t.region;r.hackAttachment===t&&(s=r.hackRegion,r.hackAttachment=null,r.hackRegion=null);const e=this.newMesh(s?s.texture:null,new Float32Array(t.regionUVs.length),t.regionUVs,new Uint16Array(t.triangles),V.DRAW_MODES.TRIANGLES);return typeof e._canvasPadding!="undefined"&&(e._canvasPadding=1.5),e.alpha=t.color.a,e.region=t.region,s&&this.setMeshRegion(t,e,s),r.meshes=r.meshes||{},r.meshes[t.id]=e,e}createGraphics(r,t){const s=this.newGraphics(),e=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(e),s.renderable=!1,r.currentGraphics=s,r.clippingContainer=this.newContainer(),r.clippingContainer.mask=r.currentGraphics,s}updateGraphics(r,t){const s=r.currentGraphics.geometry,e=s.graphicsData[0].shape.points,i=t.worldVerticesLength;e.length=i,t.computeWorldVertices(r,0,i,e,0,2),s.invalidate()}hackTextureBySlotIndex(r,t=null,s=null){const e=this.skeleton.slots[r];if(!e)return!1;const i=e.getAttachment();let a=i.region;return t?(a=new zt,a.texture=t,a.size=s,e.hackRegion=a,e.hackAttachment=i):(e.hackRegion=null,e.hackAttachment=null),e.currentSprite?this.setSpriteRegion(i,e.currentSprite,a):e.currentMesh&&this.setMeshRegion(i,e.currentMesh,a),!0}hackTextureBySlotName(r,t=null,s=null){const e=this.skeleton.findSlotIndex(r);return e==-1?!1:this.hackTextureBySlotIndex(e,t,s)}hackTextureAttachment(r,t,s,e=null){const i=this.skeleton.findSlotIndex(r),a=this.skeleton.getAttachmentByName(r,t);a.region.texture=s;const u=this.skeleton.slots[i];if(!u)return!1;const c=u.getAttachment();if(t===c.name){let n=a.region;return s?(n=new zt,n.texture=s,n.size=e,u.hackRegion=n,u.hackAttachment=c):(u.hackRegion=null,u.hackAttachment=null),u.currentSprite&&u.currentSprite.region!=n?(this.setSpriteRegion(c,u.currentSprite,n),u.currentSprite.region=n):u.currentMesh&&u.currentMesh.region!=n&&this.setMeshRegion(c,u.currentMesh,n),!0}return!1}newContainer(){return new Pt.Container}newSprite(r){return new rs(r)}newGraphics(){return new ot.Graphics}newMesh(r,t,s,e,i){return new as(r,t,s,e,i)}transformHack(){return 1}hackAttachmentGroups(r,t,s){if(!r)return;const e=[],i=[];for(let a=0,u=this.skeleton.slots.length;a<u;a++){const c=this.skeleton.slots[a],n=c.currentSpriteName||c.currentMeshName||"",o=c.currentSprite||c.currentMesh;n.endsWith(r)?(o.parentGroup=t,i.push(o)):s&&o&&(o.parentGroup=s,e.push(o))}return[e,i]}destroy(r){this.debug=null;for(let t=0,s=this.skeleton.slots.length;t<s;t++){const e=this.skeleton.slots[t];for(const i in e.meshes)e.meshes[i].destroy(r);e.meshes=null;for(const i in e.sprites)e.sprites[i].destroy(r);e.sprites=null}for(let t=0,s=this.slotContainers.length;t<s;t++)this.slotContainers[t].destroy(r);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(r)}};let Kt=os;Kt.clippingPolygon=[],Object.defineProperty(Kt.prototype,"visible",{get(){return this._visible},set(r){r!==this._visible&&(this._visible=r,r&&(this.lastTime=0))}});class Os{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(t){this.registeredSpines.has(t)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);const s={parentDebugContainer:new Pt.Container,bones:new Pt.Container,skeletonXY:new ot.Graphics,regionAttachmentsShape:new ot.Graphics,meshTrianglesLine:new ot.Graphics,meshHullLine:new ot.Graphics,clippingPolygon:new ot.Graphics,boundingBoxesRect:new ot.Graphics,boundingBoxesCircle:new ot.Graphics,boundingBoxesPolygon:new ot.Graphics,pathsCurve:new ot.Graphics,pathsLine:new ot.Graphics};s.parentDebugContainer.addChild(s.bones),s.parentDebugContainer.addChild(s.skeletonXY),s.parentDebugContainer.addChild(s.regionAttachmentsShape),s.parentDebugContainer.addChild(s.meshTrianglesLine),s.parentDebugContainer.addChild(s.meshHullLine),s.parentDebugContainer.addChild(s.clippingPolygon),s.parentDebugContainer.addChild(s.boundingBoxesRect),s.parentDebugContainer.addChild(s.boundingBoxesCircle),s.parentDebugContainer.addChild(s.boundingBoxesPolygon),s.parentDebugContainer.addChild(s.pathsCurve),s.parentDebugContainer.addChild(s.pathsLine),t.addChild(s.parentDebugContainer),this.registeredSpines.set(t,s)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const s=this.registeredSpines.get(t);s.skeletonXY.clear(),s.regionAttachmentsShape.clear(),s.meshTrianglesLine.clear(),s.meshHullLine.clear(),s.clippingPolygon.clear(),s.boundingBoxesRect.clear(),s.boundingBoxesCircle.clear(),s.boundingBoxesPolygon.clear(),s.pathsCurve.clear(),s.pathsLine.clear();for(let a=s.bones.children.length;a>0;a--)s.bones.children[a-1].destroy({children:!0,texture:!0,baseTexture:!0});const e=t.scale.x||t.scale.y||1,i=this.lineWidth/e;this.drawBones&&this.drawBonesFunc(t,s,i,e),this.drawPaths&&this.drawPathsFunc(t,s,i),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,s,i),this.drawClipping&&this.drawClippingFunc(t,s,i),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,s,i),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,s,i)}drawBonesFunc(t,s,e,i){const a=t.skeleton,u=a.x,c=a.y,n=a.bones;s.skeletonXY.lineStyle(e,this.skeletonXYColor,1);for(let l=0,d=n.length;l<d;l++){const h=n[l],m=h.data.length,f=u+h.matrix.tx,g=c+h.matrix.ty,w=u+m*h.matrix.a+h.matrix.tx,S=c+m*h.matrix.b+h.matrix.ty;if(h.data.name==="root"||h.data.parent===null)continue;const p=Math.abs(f-w),b=Math.abs(g-S),x=Math.pow(p,2),y=b,k=Math.pow(b,2),C=Math.sqrt(x+k),T=Math.pow(C,2),M=Math.PI/180,Y=Math.acos((T+k-x)/(2*y*C))||0;if(C===0)continue;const I=new ot.Graphics;s.bones.addChild(I);const B=C/50/i;I.beginFill(this.bonesColor,1),I.drawPolygon(0,0,0-B,C-B*3,0,C-B,0+B,C-B*3),I.endFill(),I.x=f,I.y=g,I.pivot.y=C;let X=0;f<w&&g<S?X=-Y+180*M:f>w&&g<S?X=180*M+Y:f>w&&g>S?X=-Y:f<w&&g>S?X=Y:g===S&&f<w?X=90*M:g===S&&f>w?X=-90*M:f===w&&g<S?X=180*M:f===w&&g>S&&(X=0),I.rotation=X,I.lineStyle(e+B/2.4,this.bonesColor,1),I.beginFill(0,.6),I.drawCircle(0,C,B*1.2),I.endFill()}const o=e*3;s.skeletonXY.moveTo(u-o,c-o),s.skeletonXY.lineTo(u+o,c+o),s.skeletonXY.moveTo(u+o,c-o),s.skeletonXY.lineTo(u-o,c+o)}drawRegionAttachmentsFunc(t,s,e){const a=t.skeleton.slots;s.regionAttachmentsShape.lineStyle(e,this.regionAttachmentsColor,1);for(let u=0,c=a.length;u<c;u++){const n=a[u],o=n.getAttachment();if(o==null||o.type!==Q.Region)continue;const l=o,d=new Float32Array(8);l.updateOffset&&l.updateOffset(),l.computeWorldVertices(n,d,0,2),s.regionAttachmentsShape.drawPolygon(Array.from(d.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,s,e){const a=t.skeleton.slots;s.meshHullLine.lineStyle(e,this.meshHullColor,1),s.meshTrianglesLine.lineStyle(e,this.meshTrianglesColor,1);for(let u=0,c=a.length;u<c;u++){const n=a[u];if(!n.bone.active)continue;const o=n.getAttachment();if(o==null||o.type!==Q.Mesh)continue;const l=o,d=new Float32Array(l.worldVerticesLength),h=l.triangles;let m=l.hullLength;if(l.computeWorldVertices(n,0,l.worldVerticesLength,d,0,2),this.drawMeshTriangles)for(let f=0,g=h.length;f<g;f+=3){const w=h[f]*2,S=h[f+1]*2,p=h[f+2]*2;s.meshTrianglesLine.moveTo(d[w],d[w+1]),s.meshTrianglesLine.lineTo(d[S],d[S+1]),s.meshTrianglesLine.lineTo(d[p],d[p+1])}if(this.drawMeshHull&&m>0){m=(m>>1)*2;let f=d[m-2],g=d[m-1];for(let w=0,S=m;w<S;w+=2){const p=d[w],b=d[w+1];s.meshHullLine.moveTo(p,b),s.meshHullLine.lineTo(f,g),f=p,g=b}}}}drawClippingFunc(t,s,e){const a=t.skeleton.slots;s.clippingPolygon.lineStyle(e,this.clippingPolygonColor,1);for(let u=0,c=a.length;u<c;u++){const n=a[u];if(!n.bone.active)continue;const o=n.getAttachment();if(o==null||o.type!==Q.Clipping)continue;const l=o,d=l.worldVerticesLength,h=new Float32Array(d);l.computeWorldVertices(n,0,d,h,0,2),s.clippingPolygon.drawPolygon(Array.from(h))}}drawBoundingBoxesFunc(t,s,e){s.boundingBoxesRect.lineStyle(e,this.boundingBoxesRectColor,5);const i=new ge;i.update(t.skeleton,!0),s.boundingBoxesRect.drawRect(i.minX,i.minY,i.getWidth(),i.getHeight());const a=i.polygons,u=(c,n,o)=>{if(s.boundingBoxesPolygon.lineStyle(e,this.boundingBoxesPolygonColor,1),s.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),o<3)throw new Error("Polygon must contain at least 3 vertices");const l=[],d=e*2;for(let h=0,m=c.length;h<m;h+=2){const f=c[h],g=c[h+1];s.boundingBoxesCircle.lineStyle(0),s.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),s.boundingBoxesCircle.drawCircle(f,g,d),s.boundingBoxesCircle.endFill(),l.push(f,g)}s.boundingBoxesPolygon.drawPolygon(l),s.boundingBoxesPolygon.endFill()};for(let c=0,n=a.length;c<n;c++){const o=a[c];u(o,0,o.length)}}drawPathsFunc(t,s,e){const a=t.skeleton.slots;s.pathsCurve.lineStyle(e,this.pathsCurveColor,1),s.pathsLine.lineStyle(e,this.pathsLineColor,1);for(let u=0,c=a.length;u<c;u++){const n=a[u];if(!n.bone.active)continue;const o=n.getAttachment();if(o==null||o.type!==Q.Path)continue;const l=o;let d=l.worldVerticesLength;const h=new Float32Array(d);l.computeWorldVertices(n,0,d,h,0,2);let m=h[2],f=h[3],g=0,w=0;if(l.closed){const S=h[0],p=h[1],b=h[d-2],x=h[d-1];g=h[d-4],w=h[d-3],s.pathsCurve.moveTo(m,f),s.pathsCurve.bezierCurveTo(S,p,b,x,g,w),s.pathsLine.moveTo(m,f),s.pathsLine.lineTo(S,p),s.pathsLine.moveTo(g,w),s.pathsLine.lineTo(b,x)}d-=4;for(let S=4;S<d;S+=6){const p=h[S],b=h[S+1],x=h[S+2],y=h[S+3];g=h[S+4],w=h[S+5],s.pathsCurve.moveTo(m,f),s.pathsCurve.bezierCurveTo(p,b,x,y,g,w),s.pathsLine.moveTo(m,f),s.pathsLine.lineTo(p,b),s.pathsLine.moveTo(g,w),s.pathsLine.lineTo(x,y),m=g,f=w}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t),this.registeredSpines.get(t).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t)}}const Ws={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:vt.LoaderParserPriority.Normal},test(r){return vt.checkExtension(r,".atlas")},async load(r){return await(await V.settings.ADAPTER.fetch(r)).text()},testParse(r,t){const s=vt.checkExtension(t.src,".atlas"),e=typeof r=="string";return Promise.resolve(s&&e)},async parse(r,t,s){const e=t.data;let i=V.utils.path.dirname(t.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");let a=null,u=null;const c=new Promise((l,d)=>{a=l,u=d});let n;const o=l=>{l||u(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),a(n)};if(e.image||e.images){const l=Object.assign(e.image?{default:e.image}:{},e.images);n=new Ht(r,(d,h)=>{const m=l[d]||l.default;m&&m.baseTexture?h(m.baseTexture):h(m)},o)}else n=new Ht(r,ls(s,i,e.imageMetadata),o);return await c},unload(r){r.dispose()}}},ls=(r,t,s)=>async(e,i)=>{const a=V.utils.path.join(...t.split(V.utils.path.sep),e),u=await r.load({src:a,data:s});i(u.baseTexture)};V.extensions.add(Ws);function cs(r){return r.hasOwnProperty("bones")}function qs(r){return r instanceof ArrayBuffer}class Us{constructor(){}installLoader(){const t=this,s={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:vt.LoaderParserPriority.Normal},test(e){return vt.checkExtension(e,".skel")},async load(e){return await(await V.settings.ADAPTER.fetch(e)).arrayBuffer()},testParse(e,i){var n;const a=vt.checkExtension(i.src,".json")&&cs(e),u=vt.checkExtension(i.src,".skel")&&qs(e),c=((n=i.data)==null?void 0:n.spineAtlas)===!1;return Promise.resolve(a&&!c||u)},async parse(e,i,a){var p;const u=V.utils.path.extname(i.src).toLowerCase(),c=V.utils.path.basename(i.src,u);let n=V.utils.path.dirname(i.src);n&&n.lastIndexOf("/")!==n.length-1&&(n+="/");const o=vt.checkExtension(i.src,".json")&&cs(e);let l=null,d=e;o?l=t.createJsonParser():(l=t.createBinaryParser(),d=new Uint8Array(e));const h=i.data||{},m=(p=h==null?void 0:h.spineSkeletonScale)!=null?p:null;m&&(l.scale=m);const f=h.spineAtlas;if(f&&f.pages)return t.parseData(l,f,d);const g=h.atlasRawData;if(g){let b=null,x=null;const y=new Promise((T,M)=>{b=T,x=M}),k=new Ht(g,ls(a,n,h.imageMetadata),T=>{T||x(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),b(k)}),C=await y;return t.parseData(l,C,d)}let w=h.spineAtlasFile;w||(w=`${n+c}.atlas`);const S=await a.load({src:w,data:h,alias:h.spineAtlasAlias});return t.parseData(l,S,d)}}};return V.extensions.add(s),s}}class xe{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const hs=class extends xe{constructor(r){super(r),this.id=hs.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(r,t){this.computeWorldVertices(r,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(r,t,s,e,i,a){s=i+(s>>1)*a;const u=r.bone.skeleton,c=r.deform;let n=this.vertices;const o=this.bones;if(!o){c.length>0&&(n=c);const m=r.bone.matrix,f=m.tx,g=m.ty,w=m.a,S=m.c,p=m.b,b=m.d;for(let x=t,y=i;y<s;x+=2,y+=a){const k=n[x],C=n[x+1];e[y]=k*w+C*S+f,e[y+1]=k*p+C*b+g}return}let l=0,d=0;for(let m=0;m<t;m+=2){const f=o[l];l+=f+1,d+=f}const h=u.bones;if(c.length==0)for(let m=i,f=d*3;m<s;m+=a){let g=0,w=0,S=o[l++];for(S+=l;l<S;l++,f+=3){const p=h[o[l]].matrix,b=n[f],x=n[f+1],y=n[f+2];g+=(b*p.a+x*p.c+p.tx)*y,w+=(b*p.b+x*p.d+p.ty)*y}e[m]=g,e[m+1]=w}else{const m=c;for(let f=i,g=d*3,w=d<<1;f<s;f+=a){let S=0,p=0,b=o[l++];for(b+=l;l<b;l++,g+=3,w+=2){const x=h[o[l]].matrix,y=n[g]+m[w],k=n[g+1]+m[w+1],C=n[g+2];S+=(y*x.a+k*x.c+x.tx)*C,p+=(y*x.b+k*x.d+x.ty)*C}e[f]=S,e[f+1]=p}}}copyTo(r){this.bones?(r.bones=new Array(this.bones.length),R.arrayCopy(this.bones,0,r.bones,0,this.bones.length)):r.bones=null,this.vertices&&(r.vertices=R.newFloatArray(this.vertices.length),R.arrayCopy(this.vertices,0,r.vertices,0,this.vertices.length)),r.worldVerticesLength=this.worldVerticesLength,r.timelineAttachment=this.timelineAttachment}};let ct=hs;ct.nextID=0;class Jt extends ct{constructor(t){super(t),this.type=Q.BoundingBox,this.color=new D(1,1,1,1)}copy(){const t=new Jt(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Qt extends ct{constructor(t){super(t),this.type=Q.Clipping,this.endSlot=null,this.color=new D(.2275,.2275,.8078,1)}copy(){const t=new Qt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ft extends ct{constructor(t,s){super(t),this.type=Q.Mesh,this.region=null,this.triangles=[],this.color=new D(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new D(0,0,0,0),this.path=s}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Ft(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),R.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),R.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),R.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,s,e,i,a,u){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,s,e,i,a,u)}newLinkedMesh(){const t=new Ft(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class Bt extends ct{constructor(t){super(t),this.type=Q.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new D(1,1,1,1)}copy(){const t=new Bt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),R.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Zt extends ct{constructor(t){super(t),this.type=Q.Point,this.x=0,this.y=0,this.rotation=0,this.color=new D(.38,.94,0,1)}computeWorldPosition(t,s){const e=t.matrix;return s.x=this.x*e.a+this.y*e.c+t.worldX,s.y=this.x*e.b+this.y*e.d+t.worldY,s}computeWorldRotation(t){const s=t.matrix,e=E.cosDeg(this.rotation),i=E.sinDeg(this.rotation),a=e*s.a+i*s.c,u=e*s.b+i*s.d;return Math.atan2(u,a)*E.radDeg}copy(){const t=new Zt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const ds=class extends xe{constructor(r,t){super(r),this.type=Q.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new D(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=R.newFloatArray(8),this.uvs=R.newFloatArray(8),this.tempColor=new D(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const r=this.region,t=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,e=-this.width/2*this.scaleX+this.region.offsetX*t,i=-this.height/2*this.scaleY+this.region.offsetY*s,a=e+this.region.width*t,u=i+this.region.height*s,c=this.rotation*Math.PI/180,n=Math.cos(c),o=Math.sin(c),l=this.x,d=this.y,h=e*n+l,m=e*o,f=i*n+d,g=i*o,w=a*n+l,S=a*o,p=u*n+d,b=u*o,x=this.offset;x[0]=h-g,x[1]=f+m,x[2]=h-b,x[3]=p+m,x[4]=w-b,x[5]=p+S,x[6]=w-g,x[7]=f+S;const y=this.uvs;r.degrees==90?(y[2]=r.u,y[3]=r.v2,y[4]=r.u,y[5]=r.v,y[6]=r.u2,y[7]=r.v,y[0]=r.u2,y[1]=r.v2):(y[0]=r.u,y[1]=r.v2,y[2]=r.u,y[3]=r.v,y[4]=r.u2,y[5]=r.v,y[6]=r.u2,y[7]=r.v2)}computeWorldVertices(r,t,s,e){this.sequence!=null&&this.sequence.apply(r,this);const i=r.bone,a=this.offset,u=i.matrix,c=u.tx,n=u.ty,o=u.a,l=u.c,d=u.b,h=u.d;let m=0,f=0;m=a[0],f=a[1],t[s]=m*o+f*l+c,t[s+1]=m*d+f*h+n,s+=e,m=a[2],f=a[3],t[s]=m*o+f*l+c,t[s+1]=m*d+f*h+n,s+=e,m=a[4],f=a[5],t[s]=m*o+f*l+c,t[s+1]=m*d+f*h+n,s+=e,m=a[6],f=a[7],t[s]=m*o+f*l+c,t[s+1]=m*d+f*h+n}copy(){const r=new ds(this.name,this.path);return r.region=this.region,r.rendererObject=this.rendererObject,r.x=this.x,r.y=this.y,r.scaleX=this.scaleX,r.scaleY=this.scaleY,r.rotation=this.rotation,r.width=this.width,r.height=this.height,R.arrayCopy(this.uvs,0,r.uvs,0,8),R.arrayCopy(this.offset,0,r.offset,0,8),r.color.setFromColor(this.color),r.sequence=this.sequence!=null?this.sequence.copy():null,r}};let q=ds;q.X1=0,q.Y1=1,q.C1R=2,q.C1G=3,q.C1B=4,q.C1A=5,q.U1=6,q.V1=7,q.X2=8,q.Y2=9,q.C2R=10,q.C2G=11,q.C2B=12,q.C2A=13,q.U2=14,q.V2=15,q.X3=16,q.Y3=17,q.C3R=18,q.C3G=19,q.C3B=20,q.C3A=21,q.U3=22,q.V3=23,q.X4=24,q.Y4=25,q.C4R=26,q.C4G=27,q.C4B=28,q.C4A=29,q.U4=30,q.V4=31;const jt=class{constructor(r){this.id=jt.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(r)}copy(){const r=new jt(this.regions.length);return R.arrayCopy(this.regions,0,r.regions,0,this.regions.length),r.start=this.start,r.digits=this.digits,r.setupIndex=this.setupIndex,r}apply(r,t){let s=r.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const e=this.regions[s];t.region!=e&&(t.region=e)}getPath(r,t){let s=r;const e=(this.start+t).toString();for(let i=this.digits-e.length;i>0;i--)s+="0";return s+=e,s}static nextID(){return jt._nextID++}};let te=jt;te._nextID=0;var xt=(r=>(r[r.hold=0]="hold",r[r.once=1]="once",r[r.loop=2]="loop",r[r.pingpong=3]="pingpong",r[r.onceReverse=4]="onceReverse",r[r.loopReverse=5]="loopReverse",r[r.pingpongReverse=6]="pingpongReverse",r))(xt||{});const pe=[0,1,2,3,4,5,6];class ee{constructor(t,s,e){if(this.timelines=[],this.timelineIds=new fe,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(s),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let s=0;s<t.length;s++)this.timelineIds.addAll(t[s].getPropertyIds())}hasTimeline(t){for(let s=0;s<t.length;s++)if(this.timelineIds.contains(t[s]))return!0;return!1}apply(t,s,e,i,a,u,c,n){if(!t)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(e%=this.duration,s>0&&(s%=this.duration));const o=this.timelines;for(let l=0,d=o.length;l<d;l++)o[l].apply(t,s,e,a,u,c,n)}}const H={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class Z{constructor(t,s){this.propertyIds=s,this.frames=R.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,s){const e=t.length;for(let i=1;i<e;i++)if(t[i]>s)return i-1;return e-1}static search(t,s,e){const i=t.length;for(let a=e;a<i;a+=e)if(t[a]>s)return a-e;return i-e}}class ht extends Z{constructor(t,s,e){super(t,e),this.curves=R.newFloatArray(t+s*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const s=this.getFrameCount()+t*18;if(this.curves.length>s){const e=R.newFloatArray(s);R.arrayCopy(this.curves,0,e,0,s),this.curves=e}}setBezier(t,s,e,i,a,u,c,n,o,l,d){const h=this.curves;let m=this.getFrameCount()+t*18;e==0&&(h[s]=2+m);const f=(i-u*2+n)*.03,g=(a-c*2+o)*.03,w=((u-n)*3-i+l)*.006,S=((c-o)*3-a+d)*.006;let p=f*2+w,b=g*2+S,x=(u-i)*.3+f+w*.16666667,y=(c-a)*.3+g+S*.16666667,k=i+x,C=a+y;for(let T=m+18;m<T;m+=2)h[m]=k,h[m+1]=C,x+=p,y+=b,p+=w,b+=S,k+=x,C+=y}getBezierValue(t,s,e,i){const a=this.curves;if(a[i]>t){const o=this.frames[s],l=this.frames[s+e];return l+(t-o)/(a[i]-o)*(a[i+1]-l)}const u=i+18;for(i+=2;i<u;i+=2)if(a[i]>=t){const o=a[i-2],l=a[i-1];return l+(t-o)/(a[i]-o)*(a[i+1]-l)}s+=this.getFrameEntries();const c=a[u-2],n=a[u-1];return n+(t-c)/(this.frames[s]-c)*(this.frames[s+e]-n)}}class dt extends ht{constructor(t,s,e){super(t,s,[e])}getFrameEntries(){return 2}setFrame(t,s,e){t<<=1,this.frames[t]=s,this.frames[t+1]=e}getCurveValue(t){const s=this.frames;let e=s.length-2;for(let a=2;a<=e;a+=2)if(s[a]>t){e=a-2;break}const i=this.curves[e>>1];switch(i){case 0:const a=s[e],u=s[e+1];return u+(t-a)/(s[e+2]-a)*(s[e+2+1]-u);case 1:return s[e+1]}return this.getBezierValue(t,e,1,i-2)}}class se extends ht{constructor(t,s,e,i){super(t,s,[e,i])}getFrameEntries(){return 3}setFrame(t,s,e,i){t*=3,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i}}class Ot extends dt{constructor(t,s,e){super(t,s,`${H.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.rotation=n.data.rotation;return;case v.first:n.rotation+=(n.data.rotation-n.rotation)*a}return}let l=this.getCurveValue(e);switch(u){case v.setup:n.rotation=n.data.rotation+l*a;break;case v.first:case v.replace:l+=n.data.rotation-n.rotation;case v.add:n.rotation+=l*a}}}class we extends se{constructor(t,s,e){super(t,s,`${H.x}|${e}`,`${H.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.x=n.data.x,n.y=n.data.y;return;case v.first:n.x+=(n.data.x-n.x)*a,n.y+=(n.data.y-n.y)*a}return}let l=0,d=0;const h=Z.search(o,e,3),m=this.curves[h/3];switch(m){case 0:const f=o[h];l=o[h+1],d=o[h+2];const g=(e-f)/(o[h+3]-f);l+=(o[h+3+1]-l)*g,d+=(o[h+3+2]-d)*g;break;case 1:l=o[h+1],d=o[h+2];break;default:l=this.getBezierValue(e,h,1,m-2),d=this.getBezierValue(e,h,2,m+18-2)}switch(u){case v.setup:n.x=n.data.x+l*a,n.y=n.data.y+d*a;break;case v.first:case v.replace:n.x+=(n.data.x+l-n.x)*a,n.y+=(n.data.y+d-n.y)*a;break;case v.add:n.x+=l*a,n.y+=d*a}}}class be extends dt{constructor(t,s,e){super(t,s,`${H.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.x=n.data.x;return;case v.first:n.x+=(n.data.x-n.x)*a}return}const l=this.getCurveValue(e);switch(u){case v.setup:n.x=n.data.x+l*a;break;case v.first:case v.replace:n.x+=(n.data.x+l-n.x)*a;break;case v.add:n.x+=l*a}}}class ye extends dt{constructor(t,s,e){super(t,s,`${H.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.y=n.data.y;return;case v.first:n.y+=(n.data.y-n.y)*a}return}const l=this.getCurveValue(e);switch(u){case v.setup:n.y=n.data.y+l*a;break;case v.first:case v.replace:n.y+=(n.data.y+l-n.y)*a;break;case v.add:n.y+=l*a}}}class Se extends se{constructor(t,s,e){super(t,s,`${H.scaleX}|${e}`,`${H.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.scaleX=n.data.scaleX,n.scaleY=n.data.scaleY;return;case v.first:n.scaleX+=(n.data.scaleX-n.scaleX)*a,n.scaleY+=(n.data.scaleY-n.scaleY)*a}return}let l,d;const h=Z.search(o,e,3),m=this.curves[h/3];switch(m){case 0:const f=o[h];l=o[h+1],d=o[h+2];const g=(e-f)/(o[h+3]-f);l+=(o[h+3+1]-l)*g,d+=(o[h+3+2]-d)*g;break;case 1:l=o[h+1],d=o[h+2];break;default:l=this.getBezierValue(e,h,1,m-2),d=this.getBezierValue(e,h,2,m+18-2)}if(l*=n.data.scaleX,d*=n.data.scaleY,a==1)u==v.add?(n.scaleX+=l-n.data.scaleX,n.scaleY+=d-n.data.scaleY):(n.scaleX=l,n.scaleY=d);else{let f=0,g=0;if(c==et.mixOut)switch(u){case v.setup:f=n.data.scaleX,g=n.data.scaleY,n.scaleX=f+(Math.abs(l)*E.signum(f)-f)*a,n.scaleY=g+(Math.abs(d)*E.signum(g)-g)*a;break;case v.first:case v.replace:f=n.scaleX,g=n.scaleY,n.scaleX=f+(Math.abs(l)*E.signum(f)-f)*a,n.scaleY=g+(Math.abs(d)*E.signum(g)-g)*a;break;case v.add:n.scaleX+=(l-n.data.scaleX)*a,n.scaleY+=(d-n.data.scaleY)*a}else switch(u){case v.setup:f=Math.abs(n.data.scaleX)*E.signum(l),g=Math.abs(n.data.scaleY)*E.signum(d),n.scaleX=f+(l-f)*a,n.scaleY=g+(d-g)*a;break;case v.first:case v.replace:f=Math.abs(n.scaleX)*E.signum(l),g=Math.abs(n.scaleY)*E.signum(d),n.scaleX=f+(l-f)*a,n.scaleY=g+(d-g)*a;break;case v.add:n.scaleX+=(l-n.data.scaleX)*a,n.scaleY+=(d-n.data.scaleY)*a}}}}class ke extends dt{constructor(t,s,e){super(t,s,`${H.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.scaleX=n.data.scaleX;return;case v.first:n.scaleX+=(n.data.scaleX-n.scaleX)*a}return}const l=this.getCurveValue(e)*n.data.scaleX;if(a==1)u==v.add?n.scaleX+=l-n.data.scaleX:n.scaleX=l;else{let d=0;if(c==et.mixOut)switch(u){case v.setup:d=n.data.scaleX,n.scaleX=d+(Math.abs(l)*E.signum(d)-d)*a;break;case v.first:case v.replace:d=n.scaleX,n.scaleX=d+(Math.abs(l)*E.signum(d)-d)*a;break;case v.add:n.scaleX+=(l-n.data.scaleX)*a}else switch(u){case v.setup:d=Math.abs(n.data.scaleX)*E.signum(l),n.scaleX=d+(l-d)*a;break;case v.first:case v.replace:d=Math.abs(n.scaleX)*E.signum(l),n.scaleX=d+(l-d)*a;break;case v.add:n.scaleX+=(l-n.data.scaleX)*a}}}}class Ce extends dt{constructor(t,s,e){super(t,s,`${H.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.scaleY=n.data.scaleY;return;case v.first:n.scaleY+=(n.data.scaleY-n.scaleY)*a}return}const l=this.getCurveValue(e)*n.data.scaleY;if(a==1)u==v.add?n.scaleY+=l-n.data.scaleY:n.scaleY=l;else{let d=0;if(c==et.mixOut)switch(u){case v.setup:d=n.data.scaleY,n.scaleY=d+(Math.abs(l)*E.signum(d)-d)*a;break;case v.first:case v.replace:d=n.scaleY,n.scaleY=d+(Math.abs(l)*E.signum(d)-d)*a;break;case v.add:n.scaleY+=(l-n.data.scaleY)*a}else switch(u){case v.setup:d=Math.abs(n.data.scaleY)*E.signum(l),n.scaleY=d+(l-d)*a;break;case v.first:case v.replace:d=Math.abs(n.scaleY)*E.signum(l),n.scaleY=d+(l-d)*a;break;case v.add:n.scaleY+=(l-n.data.scaleY)*a}}}}class Ae extends se{constructor(t,s,e){super(t,s,`${H.shearX}|${e}`,`${H.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.shearX=n.data.shearX,n.shearY=n.data.shearY;return;case v.first:n.shearX+=(n.data.shearX-n.shearX)*a,n.shearY+=(n.data.shearY-n.shearY)*a}return}let l=0,d=0;const h=Z.search(o,e,3),m=this.curves[h/3];switch(m){case 0:const f=o[h];l=o[h+1],d=o[h+2];const g=(e-f)/(o[h+3]-f);l+=(o[h+3+1]-l)*g,d+=(o[h+3+2]-d)*g;break;case 1:l=o[h+1],d=o[h+2];break;default:l=this.getBezierValue(e,h,1,m-2),d=this.getBezierValue(e,h,2,m+18-2)}switch(u){case v.setup:n.shearX=n.data.shearX+l*a,n.shearY=n.data.shearY+d*a;break;case v.first:case v.replace:n.shearX+=(n.data.shearX+l-n.shearX)*a,n.shearY+=(n.data.shearY+d-n.shearY)*a;break;case v.add:n.shearX+=l*a,n.shearY+=d*a}}}class ve extends dt{constructor(t,s,e){super(t,s,`${H.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.shearX=n.data.shearX;return;case v.first:n.shearX+=(n.data.shearX-n.shearX)*a}return}const l=this.getCurveValue(e);switch(u){case v.setup:n.shearX=n.data.shearX+l*a;break;case v.first:case v.replace:n.shearX+=(n.data.shearX+l-n.shearX)*a;break;case v.add:n.shearX+=l*a}}}class Me extends dt{constructor(t,s,e){super(t,s,`${H.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,s,e,i,a,u,c){const n=t.bones[this.boneIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.shearY=n.data.shearY;return;case v.first:n.shearY+=(n.data.shearY-n.shearY)*a}return}const l=this.getCurveValue(e);switch(u){case v.setup:n.shearY=n.data.shearY+l*a;break;case v.first:case v.replace:n.shearY+=(n.data.shearY+l-n.shearY)*a;break;case v.add:n.shearY+=l*a}}}class Te extends ht{constructor(t,s,e){super(t,s,[`${H.rgb}|${e}`,`${H.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,s,e,i,a,u){t*=5,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=u}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color;if(e<o[0]){const S=n.data.color;switch(u){case v.setup:l.setFromColor(S);return;case v.first:l.add((S.r-l.r)*a,(S.g-l.g)*a,(S.b-l.b)*a,(S.a-l.a)*a)}return}let d=0,h=0,m=0,f=0;const g=Z.search(o,e,5),w=this.curves[g/5];switch(w){case 0:const S=o[g];d=o[g+1],h=o[g+2],m=o[g+3],f=o[g+4];const p=(e-S)/(o[g+5]-S);d+=(o[g+5+1]-d)*p,h+=(o[g+5+2]-h)*p,m+=(o[g+5+3]-m)*p,f+=(o[g+5+4]-f)*p;break;case 1:d=o[g+1],h=o[g+2],m=o[g+3],f=o[g+4];break;default:d=this.getBezierValue(e,g,1,w-2),h=this.getBezierValue(e,g,2,w+18-2),m=this.getBezierValue(e,g,3,w+18*2-2),f=this.getBezierValue(e,g,4,w+18*3-2)}a==1?l.set(d,h,m,f):(u==v.setup&&l.setFromColor(n.data.color),l.add((d-l.r)*a,(h-l.g)*a,(m-l.b)*a,(f-l.a)*a))}}class Ie extends ht{constructor(t,s,e){super(t,s,[`${H.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,s,e,i,a){t<<=2,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=a}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color;if(e<o[0]){const w=n.data.color;switch(u){case v.setup:l.r=w.r,l.g=w.g,l.b=w.b;return;case v.first:l.r+=(w.r-l.r)*a,l.g+=(w.g-l.g)*a,l.b+=(w.b-l.b)*a}return}let d=0,h=0,m=0;const f=Z.search(o,e,4),g=this.curves[f>>2];switch(g){case 0:const w=o[f];d=o[f+1],h=o[f+2],m=o[f+3];const S=(e-w)/(o[f+4]-w);d+=(o[f+4+1]-d)*S,h+=(o[f+4+2]-h)*S,m+=(o[f+4+3]-m)*S;break;case 1:d=o[f+1],h=o[f+2],m=o[f+3];break;default:d=this.getBezierValue(e,f,1,g-2),h=this.getBezierValue(e,f,2,g+18-2),m=this.getBezierValue(e,f,3,g+18*2-2)}if(a==1)l.r=d,l.g=h,l.b=m;else{if(u==v.setup){const w=n.data.color;l.r=w.r,l.g=w.g,l.b=w.b}l.r+=(d-l.r)*a,l.g+=(h-l.g)*a,l.b+=(m-l.b)*a}}}class Ye extends dt{constructor(t,s,e){super(t,s,`${H.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=n.color;if(e<this.frames[0]){const d=n.data.color;switch(u){case v.setup:o.a=d.a;return;case v.first:o.a+=(d.a-o.a)*a}return}const l=this.getCurveValue(e);a==1?o.a=l:(u==v.setup&&(o.a=n.data.color.a),o.a+=(l-o.a)*a)}}class Ee extends ht{constructor(t,s,e){super(t,s,[`${H.rgb}|${e}`,`${H.alpha}|${e}`,`${H.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,s,e,i,a,u,c,n,o){t<<=3,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=u,this.frames[t+5]=c,this.frames[t+6]=n,this.frames[t+7]=o}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color,d=n.darkColor;if(e<o[0]){const y=n.data.color,k=n.data.darkColor;switch(u){case v.setup:l.setFromColor(y),d.r=k.r,d.g=k.g,d.b=k.b;return;case v.first:l.add((y.r-l.r)*a,(y.g-l.g)*a,(y.b-l.b)*a,(y.a-l.a)*a),d.r+=(k.r-d.r)*a,d.g+=(k.g-d.g)*a,d.b+=(k.b-d.b)*a}return}let h=0,m=0,f=0,g=0,w=0,S=0,p=0;const b=Z.search(o,e,8),x=this.curves[b>>3];switch(x){case 0:const y=o[b];h=o[b+1],m=o[b+2],f=o[b+3],g=o[b+4],w=o[b+5],S=o[b+6],p=o[b+7];const k=(e-y)/(o[b+8]-y);h+=(o[b+8+1]-h)*k,m+=(o[b+8+2]-m)*k,f+=(o[b+8+3]-f)*k,g+=(o[b+8+4]-g)*k,w+=(o[b+8+5]-w)*k,S+=(o[b+8+6]-S)*k,p+=(o[b+8+7]-p)*k;break;case 1:h=o[b+1],m=o[b+2],f=o[b+3],g=o[b+4],w=o[b+5],S=o[b+6],p=o[b+7];break;default:h=this.getBezierValue(e,b,1,x-2),m=this.getBezierValue(e,b,2,x+18-2),f=this.getBezierValue(e,b,3,x+18*2-2),g=this.getBezierValue(e,b,4,x+18*3-2),w=this.getBezierValue(e,b,5,x+18*4-2),S=this.getBezierValue(e,b,6,x+18*5-2),p=this.getBezierValue(e,b,7,x+18*6-2)}if(a==1)l.set(h,m,f,g),d.r=w,d.g=S,d.b=p;else{if(u==v.setup){l.setFromColor(n.data.color);const y=n.data.darkColor;d.r=y.r,d.g=y.g,d.b=y.b}l.add((h-l.r)*a,(m-l.g)*a,(f-l.b)*a,(g-l.a)*a),d.r+=(w-d.r)*a,d.g+=(S-d.g)*a,d.b+=(p-d.b)*a}}}class Fe extends ht{constructor(t,s,e){super(t,s,[`${H.rgb}|${e}`,`${H.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,s,e,i,a,u,c,n){t*=7,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=u,this.frames[t+5]=c,this.frames[t+6]=n}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=this.frames,l=n.color,d=n.darkColor;if(e<o[0]){const x=n.data.color,y=n.data.darkColor;switch(u){case v.setup:l.r=x.r,l.g=x.g,l.b=x.b,d.r=y.r,d.g=y.g,d.b=y.b;return;case v.first:l.r+=(x.r-l.r)*a,l.g+=(x.g-l.g)*a,l.b+=(x.b-l.b)*a,d.r+=(y.r-d.r)*a,d.g+=(y.g-d.g)*a,d.b+=(y.b-d.b)*a}return}let h=0,m=0,f=0,g=0,w=0,S=0;const p=Z.search(o,e,7),b=this.curves[p/7];switch(b){case 0:const x=o[p];h=o[p+1],m=o[p+2],f=o[p+3],g=o[p+4],w=o[p+5],S=o[p+6];const y=(e-x)/(o[p+7]-x);h+=(o[p+7+1]-h)*y,m+=(o[p+7+2]-m)*y,f+=(o[p+7+3]-f)*y,g+=(o[p+7+4]-g)*y,w+=(o[p+7+5]-w)*y,S+=(o[p+7+6]-S)*y;break;case 1:h=o[p+1],m=o[p+2],f=o[p+3],g=o[p+4],w=o[p+5],S=o[p+6];break;default:h=this.getBezierValue(e,p,1,b-2),m=this.getBezierValue(e,p,2,b+18-2),f=this.getBezierValue(e,p,3,b+18*2-2),g=this.getBezierValue(e,p,4,b+18*3-2),w=this.getBezierValue(e,p,5,b+18*4-2),S=this.getBezierValue(e,p,6,b+18*5-2)}if(a==1)l.r=h,l.g=m,l.b=f,d.r=g,d.g=w,d.b=S;else{if(u==v.setup){const x=n.data.color,y=n.data.darkColor;l.r=x.r,l.g=x.g,l.b=x.b,d.r=y.r,d.g=y.g,d.b=y.b}l.r+=(h-l.r)*a,l.g+=(m-l.g)*a,l.b+=(f-l.b)*a,d.r+=(g-d.r)*a,d.g+=(w-d.g)*a,d.b+=(S-d.b)*a}}}class Xt extends Z{constructor(t,s){super(t,[`${H.attachment}|${s}`]),this.slotIndex=0,this.slotIndex=s,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,s,e){this.frames[t]=s,this.attachmentNames[t]=e}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(n.bone.active){if(c==et.mixOut){u==v.setup&&this.setAttachment(t,n,n.data.attachmentName);return}if(e<this.frames[0]){(u==v.setup||u==v.first)&&this.setAttachment(t,n,n.data.attachmentName);return}this.setAttachment(t,n,this.attachmentNames[Z.search1(this.frames,e)])}}setAttachment(t,s,e){s.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class Be extends ht{constructor(t,s,e,i){super(t,s,[`${H.deform}|${e}|${i.id}`]),this.slotIndex=0,this.slotIndex=e,this.attachment=i,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,s,e){this.frames[t]=s,this.vertices[t]=e}setBezier(t,s,e,i,a,u,c,n,o,l,d){const h=this.curves;let m=this.getFrameCount()+t*18;e==0&&(h[s]=2+m);const f=(i-u*2+n)*.03,g=o*.03-c*.06,w=((u-n)*3-i+l)*.006,S=(c-o+.33333333)*.018;let p=f*2+w,b=g*2+S,x=(u-i)*.3+f+w*.16666667,y=c*.3+g+S*.16666667,k=i+x,C=y;for(let T=m+18;m<T;m+=2)h[m]=k,h[m+1]=C,x+=p,y+=b,p+=w,b+=S,k+=x,C+=y}getCurvePercent(t,s){const e=this.curves;let i=e[s];switch(i){case 0:const n=this.frames[s];return(t-n)/(this.frames[s+this.getFrameEntries()]-n);case 1:return 0}if(i-=2,e[i]>t){const n=this.frames[s];return e[i+1]*(t-n)/(e[i]-n)}const a=i+18;for(i+=2;i<a;i+=2)if(e[i]>=t){const n=e[i-2],o=e[i-1];return o+(t-n)/(e[i]-n)*(e[i+1]-o)}const u=e[a-2],c=e[a-1];return c+(1-c)*(t-u)/(this.frames[s+this.getFrameEntries()]-u)}apply(t,s,e,i,a,u,c){const n=t.slots[this.slotIndex];if(!n.bone.active)return;const o=n.getAttachment();if(!o||!(o instanceof ct)||o.timelineAttachment!=this.attachment)return;const l=n.deform;l.length==0&&(u=v.setup);const d=this.vertices,h=d[0].length,m=this.frames;if(e<m[0]){switch(u){case v.setup:l.length=0;return;case v.first:if(a==1){l.length=0;return}l.length=h;const p=o;if(p.bones){a=1-a;for(let b=0;b<h;b++)l[b]*=a}else{const b=p.vertices;for(let x=0;x<h;x++)l[x]+=(b[x]-l[x])*a}}return}if(l.length=h,e>=m[m.length-1]){const p=d[m.length-1];if(a==1)if(u==v.add){const b=o;if(b.bones)for(let x=0;x<h;x++)l[x]+=p[x];else{const x=b.vertices;for(let y=0;y<h;y++)l[y]+=p[y]-x[y]}}else R.arrayCopy(p,0,l,0,h);else switch(u){case v.setup:{const x=o;if(x.bones)for(let y=0;y<h;y++)l[y]=p[y]*a;else{const y=x.vertices;for(let k=0;k<h;k++){const C=y[k];l[k]=C+(p[k]-C)*a}}break}case v.first:case v.replace:for(let x=0;x<h;x++)l[x]+=(p[x]-l[x])*a;break;case v.add:const b=o;if(b.bones)for(let x=0;x<h;x++)l[x]+=p[x]*a;else{const x=b.vertices;for(let y=0;y<h;y++)l[y]+=(p[y]-x[y])*a}}return}const f=Z.search1(m,e),g=this.getCurvePercent(e,f),w=d[f],S=d[f+1];if(a==1)if(u==v.add){const p=o;if(p.bones)for(let b=0;b<h;b++){const x=w[b];l[b]+=x+(S[b]-x)*g}else{const b=p.vertices;for(let x=0;x<h;x++){const y=w[x];l[x]+=y+(S[x]-y)*g-b[x]}}}else for(let p=0;p<h;p++){const b=w[p];l[p]=b+(S[p]-b)*g}else switch(u){case v.setup:{const b=o;if(b.bones)for(let x=0;x<h;x++){const y=w[x];l[x]=(y+(S[x]-y)*g)*a}else{const x=b.vertices;for(let y=0;y<h;y++){const k=w[y],C=x[y];l[y]=C+(k+(S[y]-k)*g-C)*a}}break}case v.first:case v.replace:for(let b=0;b<h;b++){const x=w[b];l[b]+=(x+(S[b]-x)*g-l[b])*a}break;case v.add:const p=o;if(p.bones)for(let b=0;b<h;b++){const x=w[b];l[b]+=(x+(S[b]-x)*g)*a}else{const b=p.vertices;for(let x=0;x<h;x++){const y=w[x];l[x]+=(y+(S[x]-y)*g-b[x])*a}}}}}const us=class extends Z{constructor(r){super(r,us.propertyIds),this.events=new Array(r)}getFrameCount(){return this.frames.length}setFrame(r,t){this.frames[r]=t.time,this.events[r]=t}apply(r,t,s,e,i,a,u){if(!e)return;const c=this.frames,n=this.frames.length;if(t>s)this.apply(r,t,Number.MAX_VALUE,e,i,a,u),t=-1;else if(t>=c[n-1])return;if(s<c[0])return;let o=0;if(t<c[0])o=0;else{o=Z.search1(c,t)+1;const l=c[o];for(;o>0&&c[o-1]==l;)o--}for(;o<n&&s>=c[o];o++)e.push(this.events[o])}};let Wt=us;Wt.propertyIds=[`${H.event}`];const fs=class extends Z{constructor(r){super(r,fs.propertyIds),this.drawOrders=new Array(r)}getFrameCount(){return this.frames.length}setFrame(r,t,s){this.frames[r]=t,this.drawOrders[r]=s}apply(r,t,s,e,i,a,u){if(u==et.mixOut){a==v.setup&&R.arrayCopy(r.slots,0,r.drawOrder,0,r.slots.length);return}if(s<this.frames[0]){(a==v.setup||a==v.first)&&R.arrayCopy(r.slots,0,r.drawOrder,0,r.slots.length);return}const c=Z.search1(this.frames,s),n=this.drawOrders[c];if(!n)R.arrayCopy(r.slots,0,r.drawOrder,0,r.slots.length);else{const o=r.drawOrder,l=r.slots;for(let d=0,h=n.length;d<h;d++)o[d]=l[n[d]]}}};let Rt=fs;Rt.propertyIds=[`${H.drawOrder}`];class Xe extends ht{constructor(t,s,e){super(t,s,[`${H.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,s,e,i,a,u,c){t*=6,this.frames[t]=s,this.frames[t+1]=e,this.frames[t+2]=i,this.frames[t+3]=a,this.frames[t+4]=u?1:0,this.frames[t+5]=c?1:0}apply(t,s,e,i,a,u,c){const n=t.ikConstraints[this.ikConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch;return;case v.first:n.mix+=(n.data.mix-n.mix)*a,n.softness+=(n.data.softness-n.softness)*a,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}return}let l=0,d=0;const h=Z.search(o,e,6),m=this.curves[h/6];switch(m){case 0:const f=o[h];l=o[h+1],d=o[h+2];const g=(e-f)/(o[h+6]-f);l+=(o[h+6+1]-l)*g,d+=(o[h+6+2]-d)*g;break;case 1:l=o[h+1],d=o[h+2];break;default:l=this.getBezierValue(e,h,1,m-2),d=this.getBezierValue(e,h,2,m+18-2)}u==v.setup?(n.mix=n.data.mix+(l-n.data.mix)*a,n.softness=n.data.softness+(d-n.data.softness)*a,c==et.mixOut?(n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch):(n.bendDirection=o[h+3],n.compress=o[h+4]!=0,n.stretch=o[h+5]!=0)):(n.mix+=(l-n.mix)*a,n.softness+=(d-n.softness)*a,c==et.mixIn&&(n.bendDirection=o[h+3],n.compress=o[h+4]!=0,n.stretch=o[h+5]!=0))}}class Re extends ht{constructor(t,s,e){super(t,s,[`${H.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,s,e,i,a,u,c,n){const o=this.frames;t*=7,o[t]=s,o[t+1]=e,o[t+2]=i,o[t+3]=a,o[t+4]=u,o[t+5]=c,o[t+6]=n}apply(t,s,e,i,a,u,c){const n=t.transformConstraints[this.transformConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){const p=n.data;switch(u){case v.setup:n.mixRotate=p.mixRotate,n.mixX=p.mixX,n.mixY=p.mixY,n.mixScaleX=p.mixScaleX,n.mixScaleY=p.mixScaleY,n.mixShearY=p.mixShearY;return;case v.first:n.mixRotate+=(p.mixRotate-n.mixRotate)*a,n.mixX+=(p.mixX-n.mixX)*a,n.mixY+=(p.mixY-n.mixY)*a,n.mixScaleX+=(p.mixScaleX-n.mixScaleX)*a,n.mixScaleY+=(p.mixScaleY-n.mixScaleY)*a,n.mixShearY+=(p.mixShearY-n.mixShearY)*a}return}let l,d,h,m,f,g;const w=Z.search(o,e,7),S=this.curves[w/7];switch(S){case 0:const p=o[w];l=o[w+1],d=o[w+2],h=o[w+3],m=o[w+4],f=o[w+5],g=o[w+6];const b=(e-p)/(o[w+7]-p);l+=(o[w+7+1]-l)*b,d+=(o[w+7+2]-d)*b,h+=(o[w+7+3]-h)*b,m+=(o[w+7+4]-m)*b,f+=(o[w+7+5]-f)*b,g+=(o[w+7+6]-g)*b;break;case 1:l=o[w+1],d=o[w+2],h=o[w+3],m=o[w+4],f=o[w+5],g=o[w+6];break;default:l=this.getBezierValue(e,w,1,S-2),d=this.getBezierValue(e,w,2,S+18-2),h=this.getBezierValue(e,w,3,S+18*2-2),m=this.getBezierValue(e,w,4,S+18*3-2),f=this.getBezierValue(e,w,5,S+18*4-2),g=this.getBezierValue(e,w,6,S+18*5-2)}if(u==v.setup){const p=n.data;n.mixRotate=p.mixRotate+(l-p.mixRotate)*a,n.mixX=p.mixX+(d-p.mixX)*a,n.mixY=p.mixY+(h-p.mixY)*a,n.mixScaleX=p.mixScaleX+(m-p.mixScaleX)*a,n.mixScaleY=p.mixScaleY+(f-p.mixScaleY)*a,n.mixShearY=p.mixShearY+(g-p.mixShearY)*a}else n.mixRotate+=(l-n.mixRotate)*a,n.mixX+=(d-n.mixX)*a,n.mixY+=(h-n.mixY)*a,n.mixScaleX+=(m-n.mixScaleX)*a,n.mixScaleY+=(f-n.mixScaleY)*a,n.mixShearY+=(g-n.mixShearY)*a}}class Pe extends dt{constructor(t,s,e){super(t,s,`${H.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,s,e,i,a,u,c){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.position=n.data.position;return;case v.first:n.position+=(n.data.position-n.position)*a}return}const l=this.getCurveValue(e);u==v.setup?n.position=n.data.position+(l-n.data.position)*a:n.position+=(l-n.position)*a}}class Le extends dt{constructor(t,s,e){super(t,s,`${H.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,s,e,i,a,u,c){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.spacing=n.data.spacing;return;case v.first:n.spacing+=(n.data.spacing-n.spacing)*a}return}const l=this.getCurveValue(e);u==v.setup?n.spacing=n.data.spacing+(l-n.data.spacing)*a:n.spacing+=(l-n.spacing)*a}}class De extends ht{constructor(t,s,e){super(t,s,[`${H.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,s,e,i,a){const u=this.frames;t<<=2,u[t]=s,u[t+1]=e,u[t+2]=i,u[t+3]=a}apply(t,s,e,i,a,u,c){const n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;const o=this.frames;if(e<o[0]){switch(u){case v.setup:n.mixRotate=n.data.mixRotate,n.mixX=n.data.mixX,n.mixY=n.data.mixY;return;case v.first:n.mixRotate+=(n.data.mixRotate-n.mixRotate)*a,n.mixX+=(n.data.mixX-n.mixX)*a,n.mixY+=(n.data.mixY-n.mixY)*a}return}let l,d,h;const m=Z.search(o,e,4),f=this.curves[m>>2];switch(f){case 0:const g=o[m];l=o[m+1],d=o[m+2],h=o[m+3];const w=(e-g)/(o[m+4]-g);l+=(o[m+4+1]-l)*w,d+=(o[m+4+2]-d)*w,h+=(o[m+4+3]-h)*w;break;case 1:l=o[m+1],d=o[m+2],h=o[m+3];break;default:l=this.getBezierValue(e,m,1,f-2),d=this.getBezierValue(e,m,2,f+18-2),h=this.getBezierValue(e,m,3,f+18*2-2)}if(u==v.setup){const g=n.data;n.mixRotate=g.mixRotate+(l-g.mixRotate)*a,n.mixX=g.mixX+(d-g.mixX)*a,n.mixY=g.mixY+(h-g.mixY)*a}else n.mixRotate+=(l-n.mixRotate)*a,n.mixX+=(d-n.mixX)*a,n.mixY+=(h-n.mixY)*a}}const It=class extends Z{constructor(r,t,s){super(r,[`${H.sequence}|${t}|${s.sequence.id}`]),this.slotIndex=t,this.attachment=s}getFrameEntries(){return It.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(r,t,s,e,i){const a=this.frames;r*=It.ENTRIES,a[r]=t,a[r+It.MODE]=s|e<<4,a[r+It.DELAY]=i}apply(r,t,s,e,i,a,u){const c=r.slots[this.slotIndex];if(!c.bone.active)return;const n=c.attachment,o=this.attachment;if(n!=o&&(!(n instanceof ct)||n.timelineAttachment!=o))return;const l=this.frames;if(s<l[0]){(a==v.setup||a==v.first)&&(c.sequenceIndex=-1);return}const d=Z.search(l,s,It.ENTRIES),h=l[d],m=l[d+It.MODE],f=l[d+It.DELAY];if(!this.attachment.sequence)return;let g=m>>4;const w=this.attachment.sequence.regions.length,S=pe[m&15];if(S!=xt.hold)switch(g+=(s-h)/f+1e-5|0,S){case xt.once:g=Math.min(w-1,g);break;case xt.loop:g%=w;break;case xt.pingpong:{const p=(w<<1)-2;g=p==0?0:g%p,g>=w&&(g=p-g);break}case xt.onceReverse:g=Math.max(w-1-g,0);break;case xt.loopReverse:g=w-1-g%w;break;case xt.pingpongReverse:{const p=(w<<1)-2;g=p==0?0:(g+w-1)%p,g>=w&&(g=p-g)}}c.sequenceIndex=g}};let Dt=It;Dt.ENTRIES=3,Dt.MODE=1,Dt.DELAY=2;const pt=class{constructor(r){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new ms(this),this.propertyIDs=new fe,this.animationsChanged=!1,this.trackEntryPool=new me(()=>new ne),this.data=r}static emptyAnimation(){return pt._emptyAnimation}update(r){r*=this.timeScale;const t=this.tracks;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(!i)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let a=r*i.timeScale;if(i.delay>0){if(i.delay-=a,i.delay>0)continue;a=-i.delay,i.delay=0}let u=i.next;if(u){const c=i.trackLast-u.delay;if(c>=0){for(u.delay=0,u.trackTime+=i.timeScale==0?0:(c/i.timeScale+r)*u.timeScale,i.trackTime+=a,this.setCurrent(s,u,!0);u.mixingFrom;)u.mixTime+=r,u=u.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&!i.mixingFrom){t[s]=null,this.queue.end(i),this.clearNext(i);continue}if(i.mixingFrom&&this.updateMixingFrom(i,r)){let c=i.mixingFrom;for(i.mixingFrom=null,c&&(c.mixingTo=null);c;)this.queue.end(c),c=c.mixingFrom}i.trackTime+=a}this.queue.drain()}updateMixingFrom(r,t){const s=r.mixingFrom;if(!s)return!0;const e=this.updateMixingFrom(s,t);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,r.mixTime>0&&r.mixTime>=r.mixDuration?((s.totalAlpha==0||r.mixDuration==0)&&(r.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=r),r.interruptAlpha=s.interruptAlpha,this.queue.end(s)),e):(s.trackTime+=t*s.timeScale,r.mixTime+=t,!1)}apply(r){if(!r)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,s=this.tracks;let e=!1;for(let u=0,c=s.length;u<c;u++){const n=s[u];if(!n||n.delay>0)continue;e=!0;const o=u==0?v.first:n.mixBlend;let l=n.alpha;n.mixingFrom?l*=this.applyMixingFrom(n,r,o):n.trackTime>=n.trackEnd&&!n.next&&(l=0);const d=n.animationLast,h=n.getAnimationTime();let m=h,f=t;n.reverse&&(m=n.animation.duration-m,f=null);const g=n.animation.timelines,w=g.length;if(u==0&&l==1||o==v.add)for(let S=0;S<w;S++){R.webkit602BugfixHelper(l,o);const p=g[S];p instanceof Xt?this.applyAttachmentTimeline(p,r,m,o,!0):p.apply(r,d,m,f,l,o,et.mixIn)}else{const S=n.timelineMode,p=n.shortestRotation,b=!p&&n.timelinesRotation.length!=w<<1;b&&(n.timelinesRotation.length=w<<1);for(let x=0;x<w;x++){const y=g[x],k=S[x]==Ne?o:v.setup;!p&&y instanceof Ot?this.applyRotateTimeline(y,r,m,l,k,n.timelinesRotation,x<<1,b):y instanceof Xt?this.applyAttachmentTimeline(y,r,m,o,!0):(R.webkit602BugfixHelper(l,o),y.apply(r,d,m,f,l,k,et.mixIn))}}this.queueEvents(n,h),t.length=0,n.nextAnimationLast=h,n.nextTrackLast=n.trackTime}const i=this.unkeyedState+ps,a=r.slots;for(let u=0,c=r.slots.length;u<c;u++){const n=a[u];if(n.attachmentState==i){const o=n.data.attachmentName;n.setAttachment(o?r.getAttachment(n.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(r,t,s){const e=r.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,s);let i=0;r.mixDuration==0?(i=1,s==v.first&&(s=v.setup)):(i=r.mixTime/r.mixDuration,i>1&&(i=1),s!=v.first&&(s=e.mixBlend));const a=i<e.attachmentThreshold,u=i<e.drawOrderThreshold,c=e.animation.timelines,n=c.length,o=e.alpha*r.interruptAlpha,l=o*(1-i),d=e.animationLast,h=e.getAnimationTime();let m=h,f=null;if(e.reverse?m=e.animation.duration-m:i<e.eventThreshold&&(f=this.events),s==v.add)for(let g=0;g<n;g++)c[g].apply(t,d,m,f,l,s,et.mixOut);else{const g=e.timelineMode,w=e.timelineHoldMix,S=e.shortestRotation,p=!S&&e.timelinesRotation.length!=n<<1;p&&(e.timelinesRotation.length=n<<1),e.totalAlpha=0;for(let b=0;b<n;b++){const x=c[b];let y=et.mixOut,k,C=0;switch(g[b]){case Ne:if(!u&&x instanceof Rt)continue;k=s,C=l;break;case gs:k=v.setup,C=l;break;case xs:k=s,C=o;break;case Ve:k=v.setup,C=o;break;default:k=v.setup;const T=w[b];C=o*Math.max(0,1-T.mixTime/T.mixDuration);break}e.totalAlpha+=C,!S&&x instanceof Ot?this.applyRotateTimeline(x,t,m,C,k,e.timelinesRotation,b<<1,p):x instanceof Xt?this.applyAttachmentTimeline(x,t,m,k,a):(R.webkit602BugfixHelper(C,s),u&&x instanceof Rt&&k==v.setup&&(y=et.mixIn),x.apply(t,d,m,f,C,k,y))}}return r.mixDuration>0&&this.queueEvents(e,h),this.events.length=0,e.nextAnimationLast=h,e.nextTrackLast=e.trackTime,i}applyAttachmentTimeline(r,t,s,e,i){const a=t.slots[r.slotIndex];a.bone.active&&(s<r.frames[0]?(e==v.setup||e==v.first)&&this.setAttachment(t,a,a.data.attachmentName,i):this.setAttachment(t,a,r.attachmentNames[Z.search1(r.frames,s)],i),a.attachmentState<=this.unkeyedState&&(a.attachmentState=this.unkeyedState+ps))}setAttachment(r,t,s,e){t.setAttachment(s?r.getAttachment(t.data.index,s):null),e&&(t.attachmentState=this.unkeyedState+Gs)}applyRotateTimeline(r,t,s,e,i,a,u,c){if(c&&(a[u]=0),e==1){r.apply(t,0,s,null,1,i,et.mixIn);return}const n=t.bones[r.boneIndex];if(!n.active)return;const o=r.frames;let l=0,d=0;if(s<o[0])switch(i){case v.setup:n.rotation=n.data.rotation;default:return;case v.first:l=n.rotation,d=n.data.rotation}else l=i==v.setup?n.data.rotation:n.rotation,d=n.data.rotation+r.getCurveValue(s);let h=0,m=d-l;if(m-=(16384-(16384.499999999996-m/360|0))*360,m==0)h=a[u];else{let f=0,g=0;c?(f=0,g=m):(f=a[u],g=a[u+1]);const w=m>0;let S=f>=0;E.signum(g)!=E.signum(m)&&Math.abs(g)<=90&&(Math.abs(f)>180&&(f+=360*E.signum(f)),S=w),h=m+f-f%360,S!=w&&(h+=360*E.signum(f)),a[u]=h}a[u+1]=m,n.rotation=l+h*e}queueEvents(r,t){const s=r.animationStart,e=r.animationEnd,i=e-s,a=r.trackLast%i,u=this.events;let c=0;const n=u.length;for(;c<n;c++){const l=u[c];if(l.time<a)break;l.time>e||this.queue.event(r,l)}let o=!1;for(r.loop?o=i==0||a>r.trackTime%i:o=t>=e&&r.animationLast<e,o&&this.queue.complete(r);c<n;c++){const l=u[c];l.time<s||this.queue.event(r,l)}}clearTracks(){const r=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,s=this.tracks.length;t<s;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=r,this.queue.drain()}clearTrack(r){if(r>=this.tracks.length)return;const t=this.tracks[r];if(!t)return;this.queue.end(t),this.clearNext(t);let s=t;for(;;){const e=s.mixingFrom;if(!e)break;this.queue.end(e),s.mixingFrom=null,s.mixingTo=null,s=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(r,t,s){const e=this.expandToIndex(r);this.tracks[r]=t,t.previous=null,e&&(s&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(r,t,s=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(r,e,s)}setAnimationWith(r,t,s=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,i=this.expandToIndex(r);i&&(i.nextTrackLast==-1?(this.tracks[r]=i.mixingFrom,this.queue.interrupt(i),this.queue.end(i),this.clearNext(i),i=i.mixingFrom,e=!1):this.clearNext(i));const a=this.trackEntry(r,t,s,i);return this.setCurrent(r,a,e),this.queue.drain(),a}addAnimation(r,t,s=!1,e=0){const i=this.data.skeletonData.findAnimation(t);if(!i)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(r,i,s,e)}addAnimationWith(r,t,s=!1,e=0){if(!t)throw new Error("animation cannot be null.");let i=this.expandToIndex(r);if(i)for(;i.next;)i=i.next;const a=this.trackEntry(r,t,s,i);return i?(i.next=a,a.previous=i,e<=0&&(e+=i.getTrackComplete()-a.mixDuration)):(this.setCurrent(r,a,!0),this.queue.drain()),a.delay=e,a}setEmptyAnimation(r,t=0){const s=this.setAnimationWith(r,pt.emptyAnimation(),!1);return s.mixDuration=t,s.trackEnd=t,s}addEmptyAnimation(r,t=0,s=0){const e=this.addAnimationWith(r,pt.emptyAnimation(),!1,s);return s<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(r=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,e=this.tracks.length;s<e;s++){const i=this.tracks[s];i&&this.setEmptyAnimation(i.trackIndex,r)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(r){return r<this.tracks.length?this.tracks[r]:(R.ensureArrayCapacity(this.tracks,r+1,null),this.tracks.length=r+1,null)}trackEntry(r,t,s,e){const i=this.trackEntryPool.obtain();return i.reset(),i.trackIndex=r,i.animation=t,i.loop=s,i.holdPrevious=!1,i.reverse=!1,i.shortestRotation=!1,i.eventThreshold=0,i.attachmentThreshold=0,i.drawOrderThreshold=0,i.animationStart=0,i.animationEnd=t.duration,i.animationLast=-1,i.nextAnimationLast=-1,i.delay=0,i.trackTime=0,i.trackLast=-1,i.nextTrackLast=-1,i.trackEnd=Number.MAX_VALUE,i.timeScale=1,i.alpha=1,i.mixTime=0,i.mixDuration=e?this.data.getMix(e.animation,t):0,i.interruptAlpha=1,i.totalAlpha=0,i.mixBlend=v.replace,i}clearNext(r){let t=r.next;for(;t;)this.queue.dispose(t),t=t.next;r.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const r=this.tracks;for(let t=0,s=r.length;t<s;t++){let e=r[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=v.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(r){const t=r.mixingTo,s=r.animation.timelines,e=r.animation.timelines.length,i=r.timelineMode;i.length=e;const a=r.timelineHoldMix;a.length=0;const u=this.propertyIDs;if(t&&t.holdPrevious){for(let c=0;c<e;c++)i[c]=u.addAll(s[c].getPropertyIds())?Ve:xs;return}t:for(let c=0;c<e;c++){const n=s[c],o=n.getPropertyIds();if(!u.addAll(o))i[c]=Ne;else if(!t||n instanceof Xt||n instanceof Rt||n instanceof Wt||!t.animation.hasTimeline(o))i[c]=gs;else{for(let l=t.mixingTo;l;l=l.mixingTo)if(!l.animation.hasTimeline(o)){if(r.mixDuration>0){i[c]=Hs,a[c]=l;continue t}break}i[c]=Ve}}}getCurrent(r){return r>=this.tracks.length?null:this.tracks[r]}addListener(r){if(!r)throw new Error("listener cannot be null.");this.listeners.push(r)}removeListener(r){const t=this.listeners.indexOf(r);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(r,t,s){pt.deprecatedWarning1||(pt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(r,t,s)}addAnimationByName(r,t,s,e){pt.deprecatedWarning2||(pt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(r,t,s,e)}hasAnimation(r){return this.data.skeletonData.findAnimation(r)!==null}hasAnimationByName(r){return pt.deprecatedWarning3||(pt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(r)}};let Nt=pt;Nt._emptyAnimation=new ee("<empty>",[],0),Nt.deprecatedWarning1=!1,Nt.deprecatedWarning2=!1,Nt.deprecatedWarning3=!1;const yt=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.shortestRotation=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=v.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const r=this.animationEnd-this.animationStart;return r==0?this.animationStart:this.trackTime%r+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(r){this.animationLast=r,this.nextAnimationLast=r}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const r=this.animationEnd-this.animationStart;if(r!=0){if(this.loop)return r*(1+(this.trackTime/r|0));if(this.trackTime<r)return r}return this.trackTime}get time(){return yt.deprecatedWarning1||(yt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(r){yt.deprecatedWarning1||(yt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=r}get endTime(){return yt.deprecatedWarning2||(yt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(r){yt.deprecatedWarning2||(yt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=r}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let ne=yt;ne.deprecatedWarning1=!1,ne.deprecatedWarning2=!1;class ms{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(it.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(it.interrupt),this.objects.push(t)}end(t){this.objects.push(it.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(it.dispose),this.objects.push(t)}complete(t){this.objects.push(it.complete),this.objects.push(t)}event(t,s){this.objects.push(it.event),this.objects.push(t),this.objects.push(s)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,s=this.animState.listeners;for(let e=0;e<t.length;e+=2){const i=t[e],a=t[e+1];switch(i){case it.start:a.listener&&a.listener.start&&a.listener.start(a);for(let c=0;c<s.length;c++){const n=s[c];n.start&&n.start(a)}break;case it.interrupt:a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let c=0;c<s.length;c++){const n=s[c];n.interrupt&&n.interrupt(a)}break;case it.end:a.listener&&a.listener.end&&a.listener.end(a);for(let c=0;c<s.length;c++){const n=s[c];n.end&&n.end(a)}case it.dispose:a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let c=0;c<s.length;c++){const n=s[c];n.dispose&&n.dispose(a)}this.animState.trackEntryPool.free(a);break;case it.complete:a.listener&&a.listener.complete&&a.listener.complete(a);for(let c=0;c<s.length;c++){const n=s[c];n.complete&&n.complete(a)}break;case it.event:const u=t[e+++2];a.listener&&a.listener.event&&a.listener.event(a,u);for(let c=0;c<s.length;c++){const n=s[c];n.event&&n.event(a,u)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var it=(r=>(r[r.start=0]="start",r[r.interrupt=1]="interrupt",r[r.end=2]="end",r[r.dispose=3]="dispose",r[r.complete=4]="complete",r[r.event=5]="event",r))(it||{});class zs{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,s){}}const Ne=0,gs=1,xs=2,Ve=3,Hs=4,ps=1,Gs=2;class ws{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,s,e){const i=this.skeletonData.findAnimation(t);if(!i)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(s);if(!a)throw new Error(`Animation not found: ${s}`);this.setMixWith(i,a,e)}setMixWith(t,s,e){if(!t)throw new Error("from cannot be null.");if(!s)throw new Error("to cannot be null.");const i=`${t.name}.${s.name}`;this.animationToMixTime[i]=e}getMix(t,s){const e=`${t.name}.${s.name}`,i=this.animationToMixTime[e];return i===void 0?this.defaultMix:i}}class bs{constructor(t){this.atlas=t}loadSequence(t,s,e){const i=e.regions;for(let a=0,u=i.length;a<u;a++){const c=e.getPath(s,a),n=this.atlas.findRegion(c);if(n==null)throw new Error(`Region not found in atlas: ${c} (sequence: ${t})`);i[a]=n,i[a].renderObject=i[a]}}newRegionAttachment(t,s,e,i){const a=new q(s,e);if(i!=null)this.loadSequence(s,e,i);else{const u=this.atlas.findRegion(e);if(!u)throw new Error(`Region not found in atlas: ${e} (region attachment: ${s})`);u.renderObject=u,a.region=u}return a}newMeshAttachment(t,s,e,i){const a=new Ft(s,e);if(i!=null)this.loadSequence(s,e,i);else{const u=this.atlas.findRegion(e);if(!u)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${s})`);u.renderObject=u,a.region=u}return a}newBoundingBoxAttachment(t,s){return new Jt(s)}newPathAttachment(t,s){return new Bt(s)}newPointAttachment(t,s){return new Zt(s)}newClippingAttachment(t,s){return new Qt(s)}}class _e{constructor(t,s,e){if(this.matrix=new V.Matrix,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=s,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,s,e,i,a,u,c){this.ax=t,this.ay=s,this.arotation=e,this.ascaleX=i,this.ascaleY=a,this.ashearX=u,this.ashearY=c;const n=this.parent,o=this.matrix,l=this.skeleton.scaleX,d=Mt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!n){const w=this.skeleton,S=e+90+c;o.a=E.cosDeg(e+u)*i*l,o.c=E.cosDeg(S)*a*l,o.b=E.sinDeg(e+u)*i*d,o.d=E.sinDeg(S)*a*d,o.tx=t*l+w.x,o.ty=s*d+w.y;return}let h=n.matrix.a,m=n.matrix.c,f=n.matrix.b,g=n.matrix.d;switch(o.tx=h*t+m*s+n.matrix.tx,o.ty=f*t+g*s+n.matrix.ty,this.data.transformMode){case nt.Normal:{const w=e+90+c,S=E.cosDeg(e+u)*i,p=E.cosDeg(w)*a,b=E.sinDeg(e+u)*i,x=E.sinDeg(w)*a;o.a=h*S+m*b,o.c=h*p+m*x,o.b=f*S+g*b,o.d=f*p+g*x;return}case nt.OnlyTranslation:{const w=e+90+c;o.a=E.cosDeg(e+u)*i,o.c=E.cosDeg(w)*a,o.b=E.sinDeg(e+u)*i,o.d=E.sinDeg(w)*a;break}case nt.NoRotationOrReflection:{let w=h*h+f*f,S=0;w>1e-4?(w=Math.abs(h*g-m*f)/w,h/=l,f/=d,m=f*w,g=h*w,S=Math.atan2(f,h)*E.radDeg):(h=0,f=0,S=90-Math.atan2(g,m)*E.radDeg);const p=e+u-S,b=e+c-S+90,x=E.cosDeg(p)*i,y=E.cosDeg(b)*a,k=E.sinDeg(p)*i,C=E.sinDeg(b)*a;o.a=h*x-m*k,o.c=h*y-m*C,o.b=f*x+g*k,o.d=f*y+g*C;break}case nt.NoScale:case nt.NoScaleOrReflection:{const w=E.cosDeg(e),S=E.sinDeg(e);let p=(h*w+m*S)/l,b=(f*w+g*S)/d,x=Math.sqrt(p*p+b*b);x>1e-5&&(x=1/x),p*=x,b*=x,x=Math.sqrt(p*p+b*b),this.data.transformMode==nt.NoScale&&h*g-m*f<0!=(l<0!=d<0)&&(x=-x);const y=Math.PI/2+Math.atan2(b,p),k=Math.cos(y)*x,C=Math.sin(y)*x,T=E.cosDeg(u)*i,M=E.cosDeg(90+c)*a,Y=E.sinDeg(u)*i,I=E.sinDeg(90+c)*a;o.a=p*T+k*Y,o.c=p*M+k*I,o.b=b*T+C*Y,o.d=b*M+C*I;break}}o.a*=l,o.c*=l,o.b*=d,o.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*E.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*E.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,s=this.matrix;if(!t){this.ax=s.tx-this.skeleton.x,this.ay=s.ty-this.skeleton.y,this.arotation=Math.atan2(s.b,s.a)*E.radDeg,this.ascaleX=Math.sqrt(s.a*s.a+s.b*s.b),this.ascaleY=Math.sqrt(s.c*s.c+s.d*s.d),this.ashearX=0,this.ashearY=Math.atan2(s.a*s.c+s.b*s.d,s.a*s.d-s.b*s.c)*E.radDeg;return}const e=t.matrix,i=1/(e.a*e.d-e.b*e.c),a=s.tx-e.tx,u=s.ty-e.ty;this.ax=a*e.d*i-u*e.c*i,this.ay=u*e.a*i-a*e.b*i;const c=i*e.d,n=i*e.a,o=i*e.c,l=i*e.b,d=c*s.a-o*s.b,h=c*s.c-o*s.d,m=n*s.b-l*s.a,f=n*s.d-l*s.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*f-h*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*h+m*f,g)*E.radDeg,this.arotation=Math.atan2(m,d)*E.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(h*h+f*f),this.ashearY=0,this.arotation=90-Math.atan2(f,h)*E.radDeg}worldToLocal(t){const s=this.matrix,e=s.a,i=s.c,a=s.b,u=s.d,c=1/(e*u-i*a),n=t.x-s.tx,o=t.y-s.ty;return t.x=n*u*c-o*i*c,t.y=o*e*c-n*a*c,t}localToWorld(t){const s=this.matrix,e=t.x,i=t.y;return t.x=e*s.a+i*s.c+s.tx,t.y=e*s.b+i*s.d+s.ty,t}worldToLocalRotation(t){const s=E.sinDeg(t),e=E.cosDeg(t),i=this.matrix;return Math.atan2(i.a*s-i.b*e,i.d*e-i.c*s)*E.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const s=E.sinDeg(t),e=E.cosDeg(t),i=this.matrix;return Math.atan2(e*i.b+s*i.d,e*i.a+s*i.c)*E.radDeg}rotateWorld(t){const s=this.matrix,e=s.a,i=s.c,a=s.b,u=s.d,c=E.cosDeg(t),n=E.sinDeg(t);s.a=c*e-n*a,s.c=c*i-n*u,s.b=n*e+c*a,s.d=n*i+c*u}}class $e{constructor(t,s,e){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=nt.Normal,this.skinRequired=!1,this.color=new D,t<0)throw new Error("index must be >= 0.");if(!s)throw new Error("name cannot be null.");this.index=t,this.name=s,this.parent=e}}class ie{constructor(t,s,e){this.name=t,this.order=s,this.skinRequired=e}}class Oe{constructor(t,s){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!s)throw new Error("data cannot be null.");this.time=t,this.data=s}}class We{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class ys{constructor(t,s){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let i=0;i<t.bones.length;i++){const a=s.findBone(t.bones[i].name);if(!a)throw new Error(`Couldn't find bone ${t.bones[i].name}`);this.bones.push(a)}const e=s.findBone(t.target.name);if(!e)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=e}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,s,e,i,a,u,c){const n=t.parent.matrix;if(!n)throw new Error("IK bone must have parent.");const o=n.a;let l=n.c;const d=n.b;let h=n.d,m=-t.ashearX-t.arotation,f=0,g=0;const w=t.skeleton.scaleX,S=Mt.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case nt.OnlyTranslation:f=s-t.worldX,g=e-t.worldY,Mt.yDown&&(g=-g);break;case nt.NoRotationOrReflection:const x=Math.abs(o*h-l*d)/(o*o+d*d),y=o/w,k=d/S;l=-k*x*w,h=y*x*S,m+=Math.atan2(k,y)*E.radDeg;default:const C=s-n.tx,T=e-n.ty,M=o*h-l*d;f=(C*h-T*l)/M-t.ax,g=(T*o-C*d)/M-t.ay}m+=Math.atan2(g,f)*E.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,b=t.ascaleY;if(i||a){switch(t.data.transformMode){case nt.NoScale:case nt.NoScaleOrReflection:f=s-t.worldX,g=e-t.worldY}const x=t.data.length*p,y=Math.sqrt(f*f+g*g);if(i&&y<x||a&&y>x&&x>1e-4){const k=(y/x-1)*c+1;p*=k,u&&(b*=k)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*c,p,b,t.ashearX,t.ashearY)}apply2(t,s,e,i,a,u,c,n,o){const l=t.ax,d=t.ay;let h=t.ascaleX,m=t.ascaleY,f=h,g=m,w=s.ascaleX;const S=t.matrix;let p=0,b=0,x=0;h<0?(h=-h,p=180,x=-1):(p=0,x=1),m<0&&(m=-m,x=-x),w<0?(w=-w,b=180):b=0;const y=s.ax;let k=0,C=0,T=0,M=S.a,Y=S.c,I=S.b,B=S.d;const X=Math.abs(h-m)<=1e-4;!X||u?(k=0,C=M*y+S.tx,T=I*y+S.ty):(k=s.ay,C=M*y+Y*k+S.tx,T=I*y+B*k+S.ty);const P=t.parent.matrix;if(!P)throw new Error("IK parent must itself have a parent.");M=P.a,Y=P.c,I=P.b,B=P.d;const O=1/(M*B-Y*I);let N=C-P.tx,L=T-P.ty;const z=(N*B-L*Y)*O-l,G=(L*M-N*I)*O-d,K=Math.sqrt(z*z+G*G);let tt=s.data.length*w,_,$;if(K<1e-4){this.apply1(t,e,i,!1,u,!1,o),s.updateWorldTransformWith(y,k,0,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY);return}N=e-P.tx,L=i-P.ty;let J=(N*B-L*Y)*O-l,at=(L*M-N*I)*O-d,mt=J*J+at*at;if(n!=0){n*=h*(w+1)*.5;const rt=Math.sqrt(mt),Ct=rt-K-tt*h+n;if(Ct>0){let At=Math.min(1,Ct/(n*2))-1;At=(Ct-n*(1-At*At))/rt,J-=At*J,at-=At*at,mt=J*J+at*at}}t:if(X){tt*=h;let rt=(mt-K*K-tt*tt)/(2*K*tt);rt<-1?(rt=-1,$=Math.PI*a):rt>1?(rt=1,$=0,u&&(M=(Math.sqrt(mt)/(K+tt)-1)*o+1,f*=M,c&&(g*=M))):$=Math.acos(rt)*a,M=K+tt*rt,Y=tt*Math.sin($),_=Math.atan2(at*M-J*Y,J*M+at*Y)}else{M=h*tt,Y=m*tt;const rt=M*M,Ct=Y*Y,At=Math.atan2(at,J);I=Ct*K*K+rt*mt-rt*Ct;const oe=-2*Ct*K,vs=Ct-rt;if(B=oe*oe-4*vs*I,B>=0){let _t=Math.sqrt(B);oe<0&&(_t=-_t),_t=-(oe+_t)*.5;const Es=_t/vs,Fs=I/_t,$t=Math.abs(Es)<Math.abs(Fs)?Es:Fs;if($t*$t<=mt){L=Math.sqrt(mt-$t*$t)*a,_=At-Math.atan2(L,$t),$=Math.atan2(L/m,($t-K)/h);break t}}let Ms=E.PI,le=K-M,ts=le*le,Ts=0,Is=0,ce=K+M,es=ce*ce,Ys=0;I=-M*K/(rt-Ct),I>=-1&&I<=1&&(I=Math.acos(I),N=M*Math.cos(I)+K,L=Y*Math.sin(I),B=N*N+L*L,B<ts&&(Ms=I,ts=B,le=N,Ts=L),B>es&&(Is=I,es=B,ce=N,Ys=L)),mt<=(ts+es)*.5?(_=At-Math.atan2(Ts*a,le),$=Ms*a):(_=At-Math.atan2(Ys*a,ce),$=Is*a)}const As=Math.atan2(k,y)*x;let Ut=t.arotation;_=(_-As)*E.radDeg+p-Ut,_>180?_-=360:_<-180&&(_+=360),t.updateWorldTransformWith(l,d,Ut+_*o,f,g,0,0),Ut=s.arotation,$=(($+As)*E.radDeg-s.ashearX)*x+b-Ut,$>180?$-=360:$<-180&&($+=360),s.updateWorldTransformWith(y,k,Ut+$*o,s.ascaleX,s.ascaleY,s.ashearX,s.ashearY)}}class qe extends ie{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Ue extends ie{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=gt.Fixed,this.spacingMode=j.Fixed,this.rotateMode=Yt.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var j=(r=>(r[r.Length=0]="Length",r[r.Fixed=1]="Fixed",r[r.Percent=2]="Percent",r[r.Proportional=3]="Proportional",r))(j||{});const St=class{constructor(r,t){if(this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!r)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=r,this.bones=new Array;for(let e=0,i=r.bones.length;e<i;e++){const a=t.findBone(r.bones[e].name);if(!a)throw new Error(`Couldn't find bone ${r.bones[e].name}.`);this.bones.push(a)}const s=t.findSlot(r.target.name);if(!s)throw new Error(`Couldn't find target bone ${r.target.name}`);this.target=s,this.position=r.position,this.spacing=r.spacing,this.mixRotate=r.mixRotate,this.mixX=r.mixX,this.mixY=r.mixY}isActive(){return this.active}update(){const r=this.target.getAttachment();if(!(r instanceof Bt))return;const t=this.mixRotate,s=this.mixX,e=this.mixY;if(t==0&&s==0&&e==0)return;const i=this.data,a=i.rotateMode==Yt.Tangent,u=i.rotateMode==Yt.ChainScale,c=this.bones,n=c.length,o=a?n:n+1,l=R.setArraySize(this.spaces,o),d=u?this.lengths=R.setArraySize(this.lengths,n):[],h=this.spacing;switch(i.spacingMode){case j.Percent:if(u)for(let x=0,y=o-1;x<y;x++){const k=c[x],C=k.data.length;if(C<St.epsilon)d[x]=0;else{const T=C*k.matrix.a,M=C*k.matrix.b;d[x]=Math.sqrt(T*T+M*M)}}R.arrayFill(l,1,o,h);break;case j.Proportional:let p=0;for(let x=0,y=o-1;x<y;){const k=c[x],C=k.data.length;if(C<St.epsilon)u&&(d[x]=0),l[++x]=h;else{const T=C*k.matrix.a,M=C*k.matrix.b,Y=Math.sqrt(T*T+M*M);u&&(d[x]=Y),l[++x]=Y,p+=Y}}if(p>0){p=o/p*h;for(let x=1;x<o;x++)l[x]*=p}break;default:const b=i.spacingMode==j.Length;for(let x=0,y=o-1;x<y;){const k=c[x],C=k.data.length;if(C<St.epsilon)u&&(d[x]=0),l[++x]=h;else{const T=C*k.matrix.a,M=C*k.matrix.b,Y=Math.sqrt(T*T+M*M);u&&(d[x]=Y),l[++x]=(b?C+h:h)*Y/C}}}const m=this.computeWorldPositions(r,o,a);let f=m[0],g=m[1],w=i.offsetRotation,S=!1;if(w==0)S=i.rotateMode==Yt.Chain;else{S=!1;const p=this.target.bone.matrix;w*=p.a*p.d-p.b*p.c>0?E.degRad:-E.degRad}for(let p=0,b=3;p<n;p++,b+=3){const x=c[p],y=x.matrix;y.tx+=(f-y.tx)*s,y.ty+=(g-y.ty)*e;const k=m[b],C=m[b+1],T=k-f,M=C-g;if(u){const Y=d[p];if(Y!=0){const I=(Math.sqrt(T*T+M*M)/Y-1)*t+1;y.a*=I,y.b*=I}}if(f=k,g=C,t>0){const Y=y.a,I=y.c,B=y.b,X=y.d;let P=0,O=0,N=0;if(a?P=m[b-1]:l[p+1]==0?P=m[b+2]:P=Math.atan2(M,T),P-=Math.atan2(B,Y),S){O=Math.cos(P),N=Math.sin(P);const L=x.data.length;f+=(L*(O*Y-N*B)-T)*t,g+=(L*(N*Y+O*B)-M)*t}else P+=w;P>E.PI?P-=E.PI2:P<-E.PI&&(P+=E.PI2),P*=t,O=Math.cos(P),N=Math.sin(P),y.a=O*Y-N*B,y.c=O*I-N*X,y.b=N*Y+O*B,y.d=N*I+O*X}x.updateAppliedTransform()}}computeWorldPositions(r,t,s){const e=this.target;let i=this.position;const a=this.spaces,u=R.setArraySize(this.positions,t*3+2);let c=this.world;const n=r.closed;let o=r.worldVerticesLength,l=o/6,d=St.NONE;if(!r.constantSpeed){const L=r.lengths;l-=n?1:2;const z=L[l];this.data.positionMode==gt.Percent&&(i*=z);let G;switch(this.data.spacingMode){case j.Percent:G=z;break;case j.Proportional:G=z/t;break;default:G=1}c=R.setArraySize(this.world,8);for(let K=0,tt=0,_=0;K<t;K++,tt+=3){const $=a[K]*G;i+=$;let J=i;if(n)J%=z,J<0&&(J+=z),_=0;else if(J<0){d!=St.BEFORE&&(d=St.BEFORE,r.computeWorldVertices(e,2,4,c,0,2)),this.addBeforePosition(J,c,0,u,tt);continue}else if(J>z){d!=St.AFTER&&(d=St.AFTER,r.computeWorldVertices(e,o-6,4,c,0,2)),this.addAfterPosition(J-z,c,0,u,tt);continue}for(;;_++){const at=L[_];if(!(J>at)){if(_==0)J/=at;else{const mt=L[_-1];J=(J-mt)/(at-mt)}break}}_!=d&&(d=_,n&&_==l?(r.computeWorldVertices(e,o-4,4,c,0,2),r.computeWorldVertices(e,0,4,c,4,2)):r.computeWorldVertices(e,_*6+2,8,c,0,2)),this.addCurvePosition(J,c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],u,tt,s||K>0&&$==0)}return u}n?(o+=2,c=R.setArraySize(this.world,o),r.computeWorldVertices(e,2,o-4,c,0,2),r.computeWorldVertices(e,0,2,c,o-4,2),c[o-2]=c[0],c[o-1]=c[1]):(l--,o-=4,c=R.setArraySize(this.world,o),r.computeWorldVertices(e,2,o,c,0,2));const h=R.setArraySize(this.curves,l);let m=0,f=c[0],g=c[1],w=0,S=0,p=0,b=0,x=0,y=0,k=0,C=0,T=0,M=0,Y=0,I=0,B=0,X=0;for(let L=0,z=2;L<l;L++,z+=6)w=c[z],S=c[z+1],p=c[z+2],b=c[z+3],x=c[z+4],y=c[z+5],k=(f-w*2+p)*.1875,C=(g-S*2+b)*.1875,T=((w-p)*3-f+x)*.09375,M=((S-b)*3-g+y)*.09375,Y=k*2+T,I=C*2+M,B=(w-f)*.75+k+T*.16666667,X=(S-g)*.75+C+M*.16666667,m+=Math.sqrt(B*B+X*X),B+=Y,X+=I,Y+=T,I+=M,m+=Math.sqrt(B*B+X*X),B+=Y,X+=I,m+=Math.sqrt(B*B+X*X),B+=Y+T,X+=I+M,m+=Math.sqrt(B*B+X*X),h[L]=m,f=x,g=y;this.data.positionMode==gt.Percent&&(i*=m);let P;switch(this.data.spacingMode){case j.Percent:P=m;break;case j.Proportional:P=m/t;break;default:P=1}const O=this.segments;let N=0;for(let L=0,z=0,G=0,K=0;L<t;L++,z+=3){const tt=a[L]*P;i+=tt;let _=i;if(n)_%=m,_<0&&(_+=m),G=0;else if(_<0){this.addBeforePosition(_,c,0,u,z);continue}else if(_>m){this.addAfterPosition(_-m,c,o-4,u,z);continue}for(;;G++){const $=h[G];if(!(_>$)){if(G==0)_/=$;else{const J=h[G-1];_=(_-J)/($-J)}break}}if(G!=d){d=G;let $=G*6;for(f=c[$],g=c[$+1],w=c[$+2],S=c[$+3],p=c[$+4],b=c[$+5],x=c[$+6],y=c[$+7],k=(f-w*2+p)*.03,C=(g-S*2+b)*.03,T=((w-p)*3-f+x)*.006,M=((S-b)*3-g+y)*.006,Y=k*2+T,I=C*2+M,B=(w-f)*.3+k+T*.16666667,X=(S-g)*.3+C+M*.16666667,N=Math.sqrt(B*B+X*X),O[0]=N,$=1;$<8;$++)B+=Y,X+=I,Y+=T,I+=M,N+=Math.sqrt(B*B+X*X),O[$]=N;B+=Y,X+=I,N+=Math.sqrt(B*B+X*X),O[8]=N,B+=Y+T,X+=I+M,N+=Math.sqrt(B*B+X*X),O[9]=N,K=0}for(_*=N;;K++){const $=O[K];if(!(_>$)){if(K==0)_/=$;else{const J=O[K-1];_=K+(_-J)/($-J)}break}}this.addCurvePosition(_*.1,f,g,w,S,p,b,x,y,u,z,s||L>0&&tt==0)}return u}addBeforePosition(r,t,s,e,i){const a=t[s],u=t[s+1],c=t[s+2]-a,n=t[s+3]-u,o=Math.atan2(n,c);e[i]=a+r*Math.cos(o),e[i+1]=u+r*Math.sin(o),e[i+2]=o}addAfterPosition(r,t,s,e,i){const a=t[s+2],u=t[s+3],c=a-t[s],n=u-t[s+1],o=Math.atan2(n,c);e[i]=a+r*Math.cos(o),e[i+1]=u+r*Math.sin(o),e[i+2]=o}addCurvePosition(r,t,s,e,i,a,u,c,n,o,l,d){if(r==0||isNaN(r)){o[l]=t,o[l+1]=s,o[l+2]=Math.atan2(i-s,e-t);return}const h=r*r,m=h*r,f=1-r,g=f*f,w=g*f,S=f*r,p=S*3,b=f*p,x=p*r,y=t*w+e*b+a*x+c*m,k=s*w+i*b+u*x+n*m;o[l]=y,o[l+1]=k,d&&(r<.001?o[l+2]=Math.atan2(i-s,e-t):o[l+2]=Math.atan2(k-(s*g+i*S*2+u*h),y-(t*g+e*S*2+a*h)))}};let Vt=St;Vt.NONE=-1,Vt.BEFORE=-2,Vt.AFTER=-3,Vt.epsilon=1e-5;class Ss{constructor(t,s){if(this.darkColor=null,this.attachment=null,this.attachmentState=0,this.sequenceIndex=-1,this.deform=new Array,!t)throw new Error("data cannot be null.");if(!s)throw new Error("bone cannot be null.");this.data=t,this.bone=s,this.color=new D,this.darkColor=t.darkColor?new D:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof ct)||!(this.attachment instanceof ct)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}class ks{constructor(t,s){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new Gt,this.active=!1,!t)throw new Error("data cannot be null.");if(!s)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let i=0;i<t.bones.length;i++){const a=s.findBone(t.bones[i].name);if(!a)throw new Error(`Couldn't find bone ${t.bones[i].name}.`);this.bones.push(a)}const e=s.findBone(t.target.name);if(!e)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=e}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,a=this.mixScaleY,u=this.mixShearY,c=s!=0||e!=0,n=this.target,o=n.matrix,l=o.a,d=o.c,h=o.b,m=o.d,f=l*m-d*h>0?E.degRad:-E.degRad,g=this.data.offsetRotation*f,w=this.data.offsetShearY*f,S=this.bones;for(let p=0,b=S.length;p<b;p++){const x=S[p],y=x.matrix;if(t!=0){const k=y.a,C=y.c,T=y.b,M=y.d;let Y=Math.atan2(h,l)-Math.atan2(T,k)+g;Y>E.PI?Y-=E.PI2:Y<-E.PI&&(Y+=E.PI2),Y*=t;const I=Math.cos(Y),B=Math.sin(Y);y.a=I*k-B*T,y.c=I*C-B*M,y.b=B*k+I*T,y.d=B*C+I*M}if(c){const k=this.temp;n.localToWorld(k.set(this.data.offsetX,this.data.offsetY)),y.tx+=(k.x-y.tx)*s,y.ty+=(k.y-y.ty)*e}if(i!=0){let k=Math.sqrt(y.a*y.a+y.b*y.b);k!=0&&(k=(k+(Math.sqrt(l*l+h*h)-k+this.data.offsetScaleX)*i)/k),y.a*=k,y.b*=k}if(a!=0){let k=Math.sqrt(y.c*y.c+y.d*y.d);k!=0&&(k=(k+(Math.sqrt(d*d+m*m)-k+this.data.offsetScaleY)*a)/k),y.c*=k,y.d*=k}if(u>0){const k=y.c,C=y.d,T=Math.atan2(C,k);let M=Math.atan2(m,d)-Math.atan2(h,l)-(T-Math.atan2(y.b,y.a));M>E.PI?M-=E.PI2:M<-E.PI&&(M+=E.PI2),M=T+(M+w)*u;const Y=Math.sqrt(k*k+C*C);y.c=Math.cos(M)*Y,y.d=Math.sin(M)*Y}x.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,a=this.mixScaleY,u=this.mixShearY,c=s!=0||e!=0,n=this.target,o=n.matrix,l=o.a,d=o.c,h=o.b,m=o.d,f=l*m-d*h>0?E.degRad:-E.degRad,g=this.data.offsetRotation*f,w=this.data.offsetShearY*f,S=this.bones;for(let p=0,b=S.length;p<b;p++){const x=S[p],y=x.matrix;if(t!=0){const k=y.a,C=y.c,T=y.b,M=y.d;let Y=Math.atan2(h,l)+g;Y>E.PI?Y-=E.PI2:Y<-E.PI&&(Y+=E.PI2),Y*=t;const I=Math.cos(Y),B=Math.sin(Y);y.a=I*k-B*T,y.c=I*C-B*M,y.b=B*k+I*T,y.d=B*C+I*M}if(c){const k=this.temp;n.localToWorld(k.set(this.data.offsetX,this.data.offsetY)),y.tx+=k.x*s,y.ty+=k.y*e}if(i!=0){const k=(Math.sqrt(l*l+h*h)-1+this.data.offsetScaleX)*i+1;y.a*=k,y.b*=k}if(a!=0){const k=(Math.sqrt(d*d+m*m)-1+this.data.offsetScaleY)*a+1;y.c*=k,y.d*=k}if(u>0){let k=Math.atan2(m,d)-Math.atan2(h,l);k>E.PI?k-=E.PI2:k<-E.PI&&(k+=E.PI2);const C=y.c,T=y.d;k=Math.atan2(T,C)+(k-E.PI/2+w)*u;const M=Math.sqrt(C*C+T*T);y.c=Math.cos(k)*M,y.d=Math.sin(k)*M}x.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,a=this.mixScaleY,u=this.mixShearY,c=this.target,n=this.bones;for(let o=0,l=n.length;o<l;o++){const d=n[o];let h=d.arotation;if(t!=0){let p=c.arotation-h+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,h+=p*t}let m=d.ax,f=d.ay;m+=(c.ax-m+this.data.offsetX)*s,f+=(c.ay-f+this.data.offsetY)*e;let g=d.ascaleX,w=d.ascaleY;i!=0&&g!=0&&(g=(g+(c.ascaleX-g+this.data.offsetScaleX)*i)/g),a!=0&&w!=0&&(w=(w+(c.ascaleY-w+this.data.offsetScaleY)*a)/w);let S=d.ashearY;if(u!=0){let p=c.ashearY-S+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,S+=p*u}d.updateWorldTransformWith(m,f,h,g,w,d.ashearX,S)}}applyRelativeLocal(){const t=this.mixRotate,s=this.mixX,e=this.mixY,i=this.mixScaleX,a=this.mixScaleY,u=this.mixShearY,c=this.target,n=this.bones;for(let o=0,l=n.length;o<l;o++){const d=n[o],h=d.arotation+(c.arotation+this.data.offsetRotation)*t,m=d.ax+(c.ax+this.data.offsetX)*s,f=d.ay+(c.ay+this.data.offsetY)*e,g=d.ascaleX*((c.ascaleX-1+this.data.offsetScaleX)*i+1),w=d.ascaleY*((c.ascaleY-1+this.data.offsetScaleY)*a+1),S=d.ashearY+(c.ashearY+this.data.offsetShearY)*u;d.updateWorldTransformWith(m,f,h,g,w,d.ashearX,S)}}}const qt=class{constructor(r){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!r)throw new Error("data cannot be null.");this.data=r,this.bones=new Array;for(let t=0;t<r.bones.length;t++){const s=r.bones[t];let e;if(!s.parent)e=new _e(s,this,null);else{const i=this.bones[s.parent.index];e=new _e(s,this,i),i.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<r.slots.length;t++){const s=r.slots[t],e=this.bones[s.boneData.index],i=new Ss(s,e);this.slots.push(i),this.drawOrder.push(i)}this.ikConstraints=new Array;for(let t=0;t<r.ikConstraints.length;t++){const s=r.ikConstraints[t];this.ikConstraints.push(new ys(s,this))}this.transformConstraints=new Array;for(let t=0;t<r.transformConstraints.length;t++){const s=r.transformConstraints[t];this.transformConstraints.push(new ks(s,this))}this.pathConstraints=new Array;for(let t=0;t<r.pathConstraints.length;t++){const s=r.pathConstraints[t];this.pathConstraints.push(new Vt(s,this))}this.color=new D(1,1,1,1),this.updateCache()}updateCache(){const r=this._updateCache;r.length=0;const t=this.bones;for(let o=0,l=t.length;o<l;o++){const d=t[o];d.sorted=d.data.skinRequired,d.active=!d.sorted}if(this.skin){const o=this.skin.bones;for(let l=0,d=this.skin.bones.length;l<d;l++){let h=this.bones[o[l].index];do h.sorted=!1,h.active=!0,h=h.parent;while(h)}}const s=this.ikConstraints,e=this.transformConstraints,i=this.pathConstraints,a=s.length,u=e.length,c=i.length,n=a+u+c;t:for(let o=0;o<n;o++){for(let l=0;l<a;l++){const d=s[l];if(d.data.order==o){this.sortIkConstraint(d);continue t}}for(let l=0;l<u;l++){const d=e[l];if(d.data.order==o){this.sortTransformConstraint(d);continue t}}for(let l=0;l<c;l++){const d=i[l];if(d.data.order==o){this.sortPathConstraint(d);continue t}}}for(let o=0,l=t.length;o<l;o++)this.sortBone(t[o])}sortIkConstraint(r){if(r.active=r.target.isActive()&&(!r.data.skinRequired||this.skin&&R.contains(this.skin.constraints,r.data,!0)),!r.active)return;const t=r.target;this.sortBone(t);const s=r.bones,e=s[0];if(this.sortBone(e),s.length==1)this._updateCache.push(r),this.sortReset(e.children);else{const i=s[s.length-1];this.sortBone(i),this._updateCache.push(r),this.sortReset(e.children),i.sorted=!0}}sortPathConstraint(r){if(r.active=r.target.bone.isActive()&&(!r.data.skinRequired||this.skin&&R.contains(this.skin.constraints,r.data,!0)),!r.active)return;const t=r.target,s=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,e);for(let c=0,n=this.data.skins.length;c<n;c++)this.sortPathConstraintAttachment(this.data.skins[c],s,e);const i=t.getAttachment();i instanceof Bt&&this.sortPathConstraintAttachmentWith(i,e);const a=r.bones,u=a.length;for(let c=0;c<u;c++)this.sortBone(a[c]);this._updateCache.push(r);for(let c=0;c<u;c++)this.sortReset(a[c].children);for(let c=0;c<u;c++)a[c].sorted=!0}sortTransformConstraint(r){if(r.active=r.target.isActive()&&(!r.data.skinRequired||this.skin&&R.contains(this.skin.constraints,r.data,!0)),!r.active)return;this.sortBone(r.target);const t=r.bones,s=t.length;if(r.data.local)for(let e=0;e<s;e++){const i=t[e];this.sortBone(i.parent),this.sortBone(i)}else for(let e=0;e<s;e++)this.sortBone(t[e]);this._updateCache.push(r);for(let e=0;e<s;e++)this.sortReset(t[e].children);for(let e=0;e<s;e++)t[e].sorted=!0}sortPathConstraintAttachment(r,t,s){const e=r.attachments[t];if(e)for(const i in e)this.sortPathConstraintAttachmentWith(e[i],s)}sortPathConstraintAttachmentWith(r,t){if(!(r instanceof Bt))return;const s=r.bones;if(!s)this.sortBone(t);else{const e=this.bones;for(let i=0,a=s.length;i<a;){let u=s[i++];for(u+=i;i<u;)this.sortBone(e[s[i++]])}}}sortBone(r){if(!r||r.sorted)return;const t=r.parent;t&&this.sortBone(t),r.sorted=!0,this._updateCache.push(r)}sortReset(r){for(let t=0,s=r.length;t<s;t++){const e=r[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const r=this.bones;for(let s=0,e=r.length;s<e;s++){const i=r[s];i.ax=i.x,i.ay=i.y,i.arotation=i.rotation,i.ascaleX=i.scaleX,i.ascaleY=i.scaleY,i.ashearX=i.shearX,i.ashearY=i.shearY}const t=this._updateCache;for(let s=0,e=t.length;s<e;s++)t[s].update()}updateWorldTransformWith(r){const t=this.getRootBone(),s=r.matrix.a,e=r.matrix.c,i=r.matrix.b,a=r.matrix.d;t.matrix.tx=s*this.x+e*this.y+r.worldX,t.matrix.ty=i*this.x+a*this.y+r.worldY;const u=t.rotation+90+t.shearY,c=E.cosDeg(t.rotation+t.shearX)*t.scaleX,n=E.cosDeg(u)*t.scaleY,o=E.sinDeg(t.rotation+t.shearX)*t.scaleX,l=E.sinDeg(u)*t.scaleY,d=this.scaleX,h=Mt.yDown?-this.scaleY:this.scaleY;t.matrix.a=(s*c+e*o)*d,t.matrix.c=(s*n+e*l)*d,t.matrix.b=(i*c+a*o)*h,t.matrix.d=(i*n+a*l)*h;const m=this._updateCache;for(let f=0,g=m.length;f<g;f++){const w=m[f];w!=t&&w.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const r=this.bones;for(let i=0,a=r.length;i<a;i++)r[i].setToSetupPose();const t=this.ikConstraints;for(let i=0,a=t.length;i<a;i++){const u=t[i];u.mix=u.data.mix,u.softness=u.data.softness,u.bendDirection=u.data.bendDirection,u.compress=u.data.compress,u.stretch=u.data.stretch}const s=this.transformConstraints;for(let i=0,a=s.length;i<a;i++){const u=s[i],c=u.data;u.mixRotate=c.mixRotate,u.mixX=c.mixX,u.mixY=c.mixY,u.mixScaleX=c.mixScaleX,u.mixScaleY=c.mixScaleY,u.mixShearY=c.mixShearY}const e=this.pathConstraints;for(let i=0,a=e.length;i<a;i++){const u=e[i],c=u.data;u.position=c.position,u.spacing=c.spacing,u.mixRotate=c.mixRotate,u.mixX=c.mixX,u.mixY=c.mixY}}setSlotsToSetupPose(){const r=this.slots;R.arrayCopy(r,0,this.drawOrder,0,r.length);for(let t=0,s=r.length;t<s;t++)r[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(r){if(!r)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==r)return i}return null}findBoneIndex(r){if(!r)throw new Error("boneName cannot be null.");const t=this.bones;for(let s=0,e=t.length;s<e;s++)if(t[s].data.name==r)return s;return-1}findSlot(r){if(!r)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==r)return i}return null}findSlotIndex(r){if(!r)throw new Error("slotName cannot be null.");const t=this.slots;for(let s=0,e=t.length;s<e;s++)if(t[s].data.name==r)return s;return-1}setSkinByName(r){const t=this.data.findSkin(r);if(!t)throw new Error(`Skin not found: ${r}`);this.setSkin(t)}setSkin(r){if(r!=this.skin){if(r)if(this.skin)r.attachAll(this,this.skin);else{const t=this.slots;for(let s=0,e=t.length;s<e;s++){const i=t[s],a=i.data.attachmentName;if(a){const u=r.getAttachment(s,a);u&&i.setAttachment(u)}}}this.skin=r,this.updateCache()}}getAttachmentByName(r,t){const s=this.data.findSlot(r);if(!s)throw new Error(`Can't find slot with name ${r}`);return this.getAttachment(s.index,t)}getAttachment(r,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(r,t);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(r,t):null}setAttachment(r,t){if(!r)throw new Error("slotName cannot be null.");const s=this.slots;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.data.name==r){let u=null;if(t&&(u=this.getAttachment(e,t),!u))throw new Error(`Attachment not found: ${t}, for slot: ${r}`);a.setAttachment(u);return}}throw new Error(`Slot not found: ${r}`)}findIkConstraint(r){if(!r)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==r)return i}return null}findTransformConstraint(r){if(!r)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==r)return i}return null}findPathConstraint(r){if(!r)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let s=0,e=t.length;s<e;s++){const i=t[s];if(i.data.name==r)return i}return null}getBoundsRect(){const r=new Gt,t=new Gt;return this.getBounds(r,t),{x:r.x,y:r.y,width:t.x,height:t.y}}getBounds(r,t,s=new Array(2)){if(!r)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,c=Number.NEGATIVE_INFINITY;for(let n=0,o=e.length;n<o;n++){const l=e[n];if(!l.bone.active)continue;let d=0,h=null;const m=l.getAttachment();if(m instanceof q)d=8,h=R.setArraySize(s,d,0),m.computeWorldVertices(l,h,0,2);else if(m instanceof Ft){const f=m;d=f.worldVerticesLength,h=R.setArraySize(s,d,0),f.computeWorldVertices(l,0,d,h,0,2)}if(h)for(let f=0,g=h.length;f<g;f+=2){const w=h[f],S=h[f+1];i=Math.min(i,w),a=Math.min(a,S),u=Math.max(u,w),c=Math.max(c,S)}}r.set(i,a),t.set(u-i,c-a)}get flipX(){return this.scaleX==-1}set flipX(r){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=r?1:-1}get flipY(){return this.scaleY==-1}set flipY(r){qt.deprecatedWarning1||(qt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=r?1:-1}};let ze=qt;ze.deprecatedWarning1=!1;class He{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const s=this.bones;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const s=this.bones;for(let e=0,i=s.length;e<i;e++)if(s[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let e=0,i=s.length;e<i;e++)if(s[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const s=this.skins;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const s=this.events;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const s=this.animations;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const s=this.ikConstraints;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const s=this.transformConstraints;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const s=this.pathConstraints;for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.name==t)return a}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const s=this.pathConstraints;for(let e=0,i=s.length;e<i;e++)if(s[e].name==t)return e;return-1}}class Ge{constructor(t,s,e){if(this.index=0,this.color=new D(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=V.BLEND_MODES.NORMAL,t<0)throw new Error("index must be >= 0.");if(!s)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=s,this.boneData=e}}class Ke extends ie{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class Je{constructor(t,s,e){this.slotIndex=t,this.name=s,this.attachment=e}}class re{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,s,e){if(!e)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][s]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const i=t.bones[e];let a=!1;for(let u=0;u<this.bones.length;u++)if(this.bones[u]==i){a=!0;break}a||this.bones.push(i)}for(let e=0;e<t.constraints.length;e++){const i=t.constraints[e];let a=!1;for(let u=0;u<this.constraints.length;u++)if(this.constraints[u]==i){a=!0;break}a||this.constraints.push(i)}const s=t.getAttachments();for(let e=0;e<s.length;e++){const i=s[e];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const i=t.bones[e];let a=!1;for(let u=0;u<this.bones.length;u++)if(this.bones[u]==i){a=!0;break}a||this.bones.push(i)}for(let e=0;e<t.constraints.length;e++){const i=t.constraints[e];let a=!1;for(let u=0;u<this.constraints.length;u++)if(this.constraints[u]==i){a=!0;break}a||this.constraints.push(i)}const s=t.getAttachments();for(let e=0;e<s.length;e++){const i=s[e];i.attachment&&(i.attachment instanceof Ft?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,s){const e=this.attachments[t];return e?e[s]:null}removeAttachment(t,s){const e=this.attachments[t];e&&delete e[s]}getAttachments(){const t=new Array;for(let s=0;s<this.attachments.length;s++){const e=this.attachments[s];if(e)for(const i in e){const a=e[i];a&&t.push(new Je(s,i,a))}}return t}getAttachmentsForSlot(t,s){const e=this.attachments[t];if(e)for(const i in e){const a=e[i];a&&s.push(new Je(t,i,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,s){let e=0;for(let i=0;i<t.slots.length;i++){const a=t.slots[i],u=a.getAttachment();if(u&&e<s.attachments.length){const c=s.attachments[e];for(const n in c){const o=c[n];if(u==o){const l=this.getAttachment(e,n);l&&a.setAttachment(l);break}}}e++}}}class Qe{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,e=new He;e.name="";const i=new ss(t),a=i.readInt32(),u=i.readInt32();e.hash=u==0&&a==0?null:u.toString(16)+a.toString(16),e.version=i.readString();const c=e.version.substr(0,3);if(c!=="4.0"&&c!=="4.1"){const d=`Spine 4.1 loader cant load version ${e.version}. Please configure your pixi-spine bundle`;console.error(d)}this.ver40=c==="4.0",e.x=i.readFloat(),e.y=i.readFloat(),e.width=i.readFloat(),e.height=i.readFloat();const n=i.readBoolean();n&&(e.fps=i.readFloat(),e.imagesPath=i.readString(),e.audioPath=i.readString());let o=0;o=i.readInt(!0);for(let d=0;d<o;d++){const h=i.readString();if(!h)throw new Error("String in string table must not be null.");i.strings.push(h)}o=i.readInt(!0);for(let d=0;d<o;d++){const h=i.readString();if(!h)throw new Error("Bone name must not be null.");const m=d==0?null:e.bones[i.readInt(!0)],f=new $e(d,h,m);f.rotation=i.readFloat(),f.x=i.readFloat()*s,f.y=i.readFloat()*s,f.scaleX=i.readFloat(),f.scaleY=i.readFloat(),f.shearX=i.readFloat(),f.shearY=i.readFloat(),f.length=i.readFloat()*s,f.transformMode=i.readInt(!0),f.skinRequired=i.readBoolean(),n&&D.rgba8888ToColor(f.color,i.readInt32()),e.bones.push(f)}o=i.readInt(!0);for(let d=0;d<o;d++){const h=i.readString();if(!h)throw new Error("Slot name must not be null.");const m=e.bones[i.readInt(!0)],f=new Ge(d,h,m);D.rgba8888ToColor(f.color,i.readInt32());const g=i.readInt32();g!=-1&&D.rgb888ToColor(f.darkColor=new D,g),f.attachmentName=i.readStringRef(),f.blendMode=i.readInt(!0),e.slots.push(f)}o=i.readInt(!0);for(let d=0,h;d<o;d++){const m=i.readString();if(!m)throw new Error("IK constraint data name must not be null.");const f=new qe(m);f.order=i.readInt(!0),f.skinRequired=i.readBoolean(),h=i.readInt(!0);for(let g=0;g<h;g++)f.bones.push(e.bones[i.readInt(!0)]);f.target=e.bones[i.readInt(!0)],f.mix=i.readFloat(),f.softness=i.readFloat()*s,f.bendDirection=i.readByte(),f.compress=i.readBoolean(),f.stretch=i.readBoolean(),f.uniform=i.readBoolean(),e.ikConstraints.push(f)}o=i.readInt(!0);for(let d=0,h;d<o;d++){const m=i.readString();if(!m)throw new Error("Transform constraint data name must not be null.");const f=new Ke(m);f.order=i.readInt(!0),f.skinRequired=i.readBoolean(),h=i.readInt(!0);for(let g=0;g<h;g++)f.bones.push(e.bones[i.readInt(!0)]);f.target=e.bones[i.readInt(!0)],f.local=i.readBoolean(),f.relative=i.readBoolean(),f.offsetRotation=i.readFloat(),f.offsetX=i.readFloat()*s,f.offsetY=i.readFloat()*s,f.offsetScaleX=i.readFloat(),f.offsetScaleY=i.readFloat(),f.offsetShearY=i.readFloat(),f.mixRotate=i.readFloat(),f.mixX=i.readFloat(),f.mixY=i.readFloat(),f.mixScaleX=i.readFloat(),f.mixScaleY=i.readFloat(),f.mixShearY=i.readFloat(),e.transformConstraints.push(f)}o=i.readInt(!0);for(let d=0,h;d<o;d++){const m=i.readString();if(!m)throw new Error("Path constraint data name must not be null.");const f=new Ue(m);f.order=i.readInt(!0),f.skinRequired=i.readBoolean(),h=i.readInt(!0);for(let g=0;g<h;g++)f.bones.push(e.bones[i.readInt(!0)]);f.target=e.slots[i.readInt(!0)],f.positionMode=i.readInt(!0),f.spacingMode=i.readInt(!0),f.rotateMode=i.readInt(!0),f.offsetRotation=i.readFloat(),f.position=i.readFloat(),f.positionMode==gt.Fixed&&(f.position*=s),f.spacing=i.readFloat(),(f.spacingMode==j.Length||f.spacingMode==j.Fixed)&&(f.spacing*=s),f.mixRotate=i.readFloat(),f.mixX=i.readFloat(),f.mixY=i.readFloat(),e.pathConstraints.push(f)}const l=this.readSkin(i,e,!0,n);l&&(e.defaultSkin=l,e.skins.push(l));{let d=e.skins.length;for(R.setArraySize(e.skins,o=d+i.readInt(!0));d<o;d++){const h=this.readSkin(i,e,!1,n);if(!h)throw new Error("readSkin() should not have returned null.");e.skins[d]=h}}o=this.linkedMeshes.length;for(let d=0;d<o;d++){const h=this.linkedMeshes[d],m=h.skin?e.findSkin(h.skin):e.defaultSkin;if(!m)throw new Error("Not skin found for linked mesh.");if(!h.parent)throw new Error("Linked mesh parent must not be null");const f=m.getAttachment(h.slotIndex,h.parent);if(!f)throw new Error(`Parent mesh not found: ${h.parent}`);h.mesh.timelineAttachment=h.inheritTimeline?f:h.mesh,h.mesh.setParentMesh(f)}this.linkedMeshes.length=0,o=i.readInt(!0);for(let d=0;d<o;d++){const h=i.readStringRef();if(!h)throw new Error;const m=new We(h);m.intValue=i.readInt(!1),m.floatValue=i.readFloat(),m.stringValue=i.readString(),m.audioPath=i.readString(),m.audioPath&&(m.volume=i.readFloat(),m.balance=i.readFloat()),e.events.push(m)}o=i.readInt(!0);for(let d=0;d<o;d++){const h=i.readString();if(!h)throw new Error("Animatio name must not be null.");e.animations.push(this.readAnimation(i,h,e))}return e}readSkin(t,s,e,i){let a=null,u=0;if(e){if(u=t.readInt(!0),u==0)return null;a=new re("default")}else{const c=t.readStringRef();if(!c)throw new Error("Skin name must not be null.");a=new re(c),a.bones.length=t.readInt(!0);for(let n=0,o=a.bones.length;n<o;n++)a.bones[n]=s.bones[t.readInt(!0)];for(let n=0,o=t.readInt(!0);n<o;n++)a.constraints.push(s.ikConstraints[t.readInt(!0)]);for(let n=0,o=t.readInt(!0);n<o;n++)a.constraints.push(s.transformConstraints[t.readInt(!0)]);for(let n=0,o=t.readInt(!0);n<o;n++)a.constraints.push(s.pathConstraints[t.readInt(!0)]);u=t.readInt(!0)}for(let c=0;c<u;c++){const n=t.readInt(!0);for(let o=0,l=t.readInt(!0);o<l;o++){const d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");const h=this.readAttachment(t,s,a,n,d,i);h&&a.setAttachment(n,d,h)}}return a}readAttachment(t,s,e,i,a,u){const c=this.scale;let n=t.readStringRef();switch(n||(n=a),t.readByte()){case Q.Region:{let o=t.readStringRef();const l=t.readFloat(),d=t.readFloat(),h=t.readFloat(),m=t.readFloat(),f=t.readFloat(),g=t.readFloat(),w=t.readFloat(),S=t.readInt32(),p=this.readSequence(t);o||(o=n);const b=this.attachmentLoader.newRegionAttachment(e,n,o,p);return b?(b.path=o,b.x=d*c,b.y=h*c,b.scaleX=m,b.scaleY=f,b.rotation=l,b.width=g*c,b.height=w*c,D.rgba8888ToColor(b.color,S),b.sequence=p,p==null&&b.updateRegion(),b):null}case Q.BoundingBox:{const o=t.readInt(!0),l=this.readVertices(t,o),d=u?t.readInt32():0,h=this.attachmentLoader.newBoundingBoxAttachment(e,n);return h?(h.worldVerticesLength=o<<1,h.vertices=l.vertices,h.bones=l.bones,u&&D.rgba8888ToColor(h.color,d),h):null}case Q.Mesh:{let o=t.readStringRef();const l=t.readInt32(),d=t.readInt(!0),h=this.readFloatArray(t,d<<1,1),m=this.readShortArray(t),f=this.readVertices(t,d),g=t.readInt(!0),w=this.readSequence(t);let S=[],p=0,b=0;u&&(S=this.readShortArray(t),p=t.readFloat(),b=t.readFloat()),o||(o=n);const x=this.attachmentLoader.newMeshAttachment(e,n,o,w);return x?(x.path=o,D.rgba8888ToColor(x.color,l),x.bones=f.bones,x.vertices=f.vertices,x.worldVerticesLength=d<<1,x.triangles=m,x.regionUVs=new Float32Array(h),x.hullLength=g<<1,x.sequence=w,u&&(x.edges=S,x.width=p*c,x.height=b*c),x):null}case Q.LinkedMesh:{let o=t.readStringRef();const l=t.readInt32(),d=t.readStringRef(),h=t.readStringRef(),m=t.readBoolean(),f=this.readSequence(t);let g=0,w=0;u&&(g=t.readFloat(),w=t.readFloat()),o||(o=n);const S=this.attachmentLoader.newMeshAttachment(e,n,o,f);return S?(S.path=o,D.rgba8888ToColor(S.color,l),S.sequence=f,u&&(S.width=g*c,S.height=w*c),this.linkedMeshes.push(new Ks(S,d,i,h,m)),S):null}case Q.Path:{const o=t.readBoolean(),l=t.readBoolean(),d=t.readInt(!0),h=this.readVertices(t,d),m=R.newArray(d/3,0);for(let w=0,S=m.length;w<S;w++)m[w]=t.readFloat()*c;const f=u?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(e,n);return g?(g.closed=o,g.constantSpeed=l,g.worldVerticesLength=d<<1,g.vertices=h.vertices,g.bones=h.bones,g.lengths=m,u&&D.rgba8888ToColor(g.color,f),g):null}case Q.Point:{const o=t.readFloat(),l=t.readFloat(),d=t.readFloat(),h=u?t.readInt32():0,m=this.attachmentLoader.newPointAttachment(e,n);return m?(m.x=l*c,m.y=d*c,m.rotation=o,u&&D.rgba8888ToColor(m.color,h),m):null}case Q.Clipping:{const o=t.readInt(!0),l=t.readInt(!0),d=this.readVertices(t,l),h=u?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(e,n);return m?(m.endSlot=s.slots[o],m.worldVerticesLength=l<<1,m.vertices=d.vertices,m.bones=d.bones,u&&D.rgba8888ToColor(m.color,h),m):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const s=new te(t.readInt(!0));return s.start=t.readInt(!0),s.digits=t.readInt(!0),s.setupIndex=t.readInt(!0),s}readDeformTimelineType(t){return this.ver40?Cs:t.readByte()}readVertices(t,s){const e=this.scale,i=s<<1,a=new Js;if(!t.readBoolean())return a.vertices=this.readFloatArray(t,i,e),a;const u=new Array,c=new Array;for(let n=0;n<s;n++){const o=t.readInt(!0);c.push(o);for(let l=0;l<o;l++)c.push(t.readInt(!0)),u.push(t.readFloat()*e),u.push(t.readFloat()*e),u.push(t.readFloat())}return a.vertices=R.toFloatArray(u),a.bones=c,a}readFloatArray(t,s,e){const i=new Array(s);if(e==1)for(let a=0;a<s;a++)i[a]=t.readFloat();else for(let a=0;a<s;a++)i[a]=t.readFloat()*e;return i}readShortArray(t){const s=t.readInt(!0),e=new Array(s);for(let i=0;i<s;i++)e[i]=t.readShort();return e}readAnimation(t,s,e){t.readInt(!0);const i=new Array,a=this.scale;for(let o=0,l=t.readInt(!0);o<l;o++){const d=t.readInt(!0);for(let h=0,m=t.readInt(!0);h<m;h++){const f=t.readByte(),g=t.readInt(!0),w=g-1;switch(f){case ln:{const S=new Xt(g,d);for(let p=0;p<g;p++)S.setFrame(p,t.readFloat(),t.readStringRef());i.push(S);break}case cn:{const S=t.readInt(!0),p=new Te(g,S,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let T=0,M=0;p.setFrame(T,b,x,y,k,C),T!=w;T++){const Y=t.readFloat(),I=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255;switch(t.readByte()){case ut:p.setStepped(T);break;case ft:W(t,p,M++,T,0,b,Y,x,I,1),W(t,p,M++,T,1,b,Y,y,B,1),W(t,p,M++,T,2,b,Y,k,X,1),W(t,p,M++,T,3,b,Y,C,P,1)}b=Y,x=I,y=B,k=X,C=P}i.push(p);break}case hn:{const S=t.readInt(!0),p=new Ie(g,S,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255;for(let C=0,T=0;p.setFrame(C,b,x,y,k),C!=w;C++){const M=t.readFloat(),Y=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255;switch(t.readByte()){case ut:p.setStepped(C);break;case ft:W(t,p,T++,C,0,b,M,x,Y,1),W(t,p,T++,C,1,b,M,y,I,1),W(t,p,T++,C,2,b,M,k,B,1)}b=M,x=Y,y=I,k=B}i.push(p);break}case dn:{const S=t.readInt(!0),p=new Ee(g,S,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255;for(let I=0,B=0;p.setFrame(I,b,x,y,k,C,T,M,Y),I!=w;I++){const X=t.readFloat(),P=t.readUnsignedByte()/255,O=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255,L=t.readUnsignedByte()/255,z=t.readUnsignedByte()/255,G=t.readUnsignedByte()/255,K=t.readUnsignedByte()/255;switch(t.readByte()){case ut:p.setStepped(I);break;case ft:W(t,p,B++,I,0,b,X,x,P,1),W(t,p,B++,I,1,b,X,y,O,1),W(t,p,B++,I,2,b,X,k,N,1),W(t,p,B++,I,3,b,X,C,L,1),W(t,p,B++,I,4,b,X,T,z,1),W(t,p,B++,I,5,b,X,M,G,1),W(t,p,B++,I,6,b,X,Y,K,1)}b=X,x=P,y=O,k=N,C=L,T=z,M=G,Y=K}i.push(p);break}case un:{const S=t.readInt(!0),p=new Fe(g,S,d);let b=t.readFloat(),x=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,T=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let Y=0,I=0;p.setFrame(Y,b,x,y,k,C,T,M),Y!=w;Y++){const B=t.readFloat(),X=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,O=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255,L=t.readUnsignedByte()/255,z=t.readUnsignedByte()/255;switch(t.readByte()){case ut:p.setStepped(Y);break;case ft:W(t,p,I++,Y,0,b,B,x,X,1),W(t,p,I++,Y,1,b,B,y,P,1),W(t,p,I++,Y,2,b,B,k,O,1),W(t,p,I++,Y,3,b,B,C,N,1),W(t,p,I++,Y,4,b,B,T,L,1),W(t,p,I++,Y,5,b,B,M,z,1)}b=B,x=X,y=P,k=O,C=N,T=L,M=z}i.push(p);break}case fn:{const S=new Ye(g,t.readInt(!0),d);let p=t.readFloat(),b=t.readUnsignedByte()/255;for(let x=0,y=0;S.setFrame(x,p,b),x!=w;x++){const k=t.readFloat(),C=t.readUnsignedByte()/255;switch(t.readByte()){case ut:S.setStepped(x);break;case ft:W(t,S,y++,x,0,p,k,b,C,1)}p=k,b=C}i.push(S)}}}}for(let o=0,l=t.readInt(!0);o<l;o++){const d=t.readInt(!0);for(let h=0,m=t.readInt(!0);h<m;h++){const f=t.readByte(),g=t.readInt(!0),w=t.readInt(!0);switch(f){case Qs:i.push(kt(t,new Ot(g,w,d),1));break;case Zs:i.push(Ze(t,new we(g,w,d),a));break;case js:i.push(kt(t,new be(g,w,d),a));break;case tn:i.push(kt(t,new ye(g,w,d),a));break;case en:i.push(Ze(t,new Se(g,w,d),1));break;case sn:i.push(kt(t,new ke(g,w,d),1));break;case nn:i.push(kt(t,new Ce(g,w,d),1));break;case rn:i.push(Ze(t,new Ae(g,w,d),1));break;case an:i.push(kt(t,new ve(g,w,d),1));break;case on:i.push(kt(t,new Me(g,w,d),1))}}}for(let o=0,l=t.readInt(!0);o<l;o++){const d=t.readInt(!0),h=t.readInt(!0),m=h-1,f=new Xe(h,t.readInt(!0),d);let g=t.readFloat(),w=t.readFloat(),S=t.readFloat()*a;for(let p=0,b=0;f.setFrame(p,g,w,S,t.readByte(),t.readBoolean(),t.readBoolean()),p!=m;p++){const x=t.readFloat(),y=t.readFloat(),k=t.readFloat()*a;switch(t.readByte()){case ut:f.setStepped(p);break;case ft:W(t,f,b++,p,0,g,x,w,y,1),W(t,f,b++,p,1,g,x,S,k,a)}g=x,w=y,S=k}i.push(f)}for(let o=0,l=t.readInt(!0);o<l;o++){const d=t.readInt(!0),h=t.readInt(!0),m=h-1,f=new Re(h,t.readInt(!0),d);let g=t.readFloat(),w=t.readFloat(),S=t.readFloat(),p=t.readFloat(),b=t.readFloat(),x=t.readFloat(),y=t.readFloat();for(let k=0,C=0;f.setFrame(k,g,w,S,p,b,x,y),k!=m;k++){const T=t.readFloat(),M=t.readFloat(),Y=t.readFloat(),I=t.readFloat(),B=t.readFloat(),X=t.readFloat(),P=t.readFloat();switch(t.readByte()){case ut:f.setStepped(k);break;case ft:W(t,f,C++,k,0,g,T,w,M,1),W(t,f,C++,k,1,g,T,S,Y,1),W(t,f,C++,k,2,g,T,p,I,1),W(t,f,C++,k,3,g,T,b,B,1),W(t,f,C++,k,4,g,T,x,X,1),W(t,f,C++,k,5,g,T,y,P,1)}g=T,w=M,S=Y,p=I,b=B,x=X,y=P}i.push(f)}for(let o=0,l=t.readInt(!0);o<l;o++){const d=t.readInt(!0),h=e.pathConstraints[d];for(let m=0,f=t.readInt(!0);m<f;m++)switch(t.readByte()){case gn:i.push(kt(t,new Pe(t.readInt(!0),t.readInt(!0),d),h.positionMode==gt.Fixed?a:1));break;case xn:i.push(kt(t,new Le(t.readInt(!0),t.readInt(!0),d),h.spacingMode==j.Length||h.spacingMode==j.Fixed?a:1));break;case pn:const g=new De(t.readInt(!0),t.readInt(!0),d);let w=t.readFloat(),S=t.readFloat(),p=t.readFloat(),b=t.readFloat();for(let x=0,y=0,k=g.getFrameCount()-1;g.setFrame(x,w,S,p,b),x!=k;x++){const C=t.readFloat(),T=t.readFloat(),M=t.readFloat(),Y=t.readFloat();switch(t.readByte()){case ut:g.setStepped(x);break;case ft:W(t,g,y++,x,0,w,C,S,T,1),W(t,g,y++,x,1,w,C,p,M,1),W(t,g,y++,x,2,w,C,b,Y,1)}w=C,S=T,p=M,b=Y}i.push(g)}}for(let o=0,l=t.readInt(!0);o<l;o++){const d=e.skins[t.readInt(!0)];for(let h=0,m=t.readInt(!0);h<m;h++){const f=t.readInt(!0);for(let g=0,w=t.readInt(!0);g<w;g++){const S=t.readStringRef();if(!S)throw new Error("attachmentName must not be null.");const p=d.getAttachment(f,S),b=this.readDeformTimelineType(t),x=t.readInt(!0),y=x-1;switch(b){case Cs:{const k=p,C=k.bones,T=k.vertices,M=C?T.length/3*2:T.length,Y=t.readInt(!0),I=new Be(x,Y,f,k);let B=t.readFloat();for(let X=0,P=0;;X++){let O,N=t.readInt(!0);if(N==0)O=C?R.newFloatArray(M):T;else{O=R.newFloatArray(M);const z=t.readInt(!0);if(N+=z,a==1)for(let G=z;G<N;G++)O[G]=t.readFloat();else for(let G=z;G<N;G++)O[G]=t.readFloat()*a;if(!C)for(let G=0,K=O.length;G<K;G++)O[G]+=T[G]}if(I.setFrame(X,B,O),X==y)break;const L=t.readFloat();switch(t.readByte()){case ut:I.setStepped(X);break;case ft:W(t,I,P++,X,0,B,L,0,1,1)}B=L}i.push(I);break}case mn:{const k=new Dt(x,f,p);for(let C=0;C<x;C++){const T=t.readFloat(),M=t.readInt32();k.setFrame(C,T,pe[M&15],M>>4,t.readFloat())}i.push(k);break}}}}}const u=t.readInt(!0);if(u>0){const o=new Rt(u),l=e.slots.length;for(let d=0;d<u;d++){const h=t.readFloat(),m=t.readInt(!0),f=R.newArray(l,0);for(let p=l-1;p>=0;p--)f[p]=-1;const g=R.newArray(l-m,0);let w=0,S=0;for(let p=0;p<m;p++){const b=t.readInt(!0);for(;w!=b;)g[S++]=w++;f[w+t.readInt(!0)]=w++}for(;w<l;)g[S++]=w++;for(let p=l-1;p>=0;p--)f[p]==-1&&(f[p]=g[--S]);o.setFrame(d,h,f)}i.push(o)}const c=t.readInt(!0);if(c>0){const o=new Wt(c);for(let l=0;l<c;l++){const d=t.readFloat(),h=e.events[t.readInt(!0)],m=new Oe(d,h);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():h.stringValue,m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),o.setFrame(l,m)}i.push(o)}let n=0;for(let o=0,l=i.length;o<l;o++)n=Math.max(n,i[o].getDuration());return new ee(s,i,n)}}Qe.BlendModeValues=[V.BLEND_MODES.NORMAL,V.BLEND_MODES.ADD,V.BLEND_MODES.MULTIPLY,V.BLEND_MODES.SCREEN];let Ks=class{constructor(t,s,e,i,a){this.mesh=t,this.skin=s,this.slotIndex=e,this.parent=i,this.inheritTimeline=a}};class Js{constructor(t=null,s=null){this.bones=t,this.vertices=s}}function kt(r,t,s){let e=r.readFloat(),i=r.readFloat()*s;for(let a=0,u=0,c=t.getFrameCount()-1;t.setFrame(a,e,i),a!=c;a++){const n=r.readFloat(),o=r.readFloat()*s;switch(r.readByte()){case ut:t.setStepped(a);break;case ft:W(r,t,u++,a,0,e,n,i,o,s)}e=n,i=o}return t}function Ze(r,t,s){let e=r.readFloat(),i=r.readFloat()*s,a=r.readFloat()*s;for(let u=0,c=0,n=t.getFrameCount()-1;t.setFrame(u,e,i,a),u!=n;u++){const o=r.readFloat(),l=r.readFloat()*s,d=r.readFloat()*s;switch(r.readByte()){case ut:t.setStepped(u);break;case ft:W(r,t,c++,u,0,e,o,i,l,s),W(r,t,c++,u,1,e,o,a,d,s)}e=o,i=l,a=d}return t}function W(r,t,s,e,i,a,u,c,n,o){t.setBezier(s,e,i,a,c,r.readFloat(),r.readFloat()*o,r.readFloat(),r.readFloat()*o,u,n)}const Qs=0,Zs=1,js=2,tn=3,en=4,sn=5,nn=6,rn=7,an=8,on=9,ln=0,cn=1,hn=2,dn=3,un=4,fn=5,Cs=0,mn=1,gn=0,xn=1,pn=2,ut=1,ft=2;class wn extends ge{}class ae{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const s=this.scale,e=new He,i=typeof t=="string"?JSON.parse(t):t,a=i.skeleton;if(a){e.hash=a.hash,e.version=a.spine;const u=e.version.substr(0,3);if(u!=="4.0"&&u!=="4.1"){const c=`Spine 4.1 loader cant load version ${a.spine}. Please configure your pixi-spine bundle`;console.error(c)}e.x=a.x,e.y=a.y,e.width=a.width,e.height=a.height,e.fps=a.fps,e.imagesPath=a.images}if(i.bones)for(let u=0;u<i.bones.length;u++){const c=i.bones[u];let n=null;const o=A(c,"parent",null);if(o!=null&&(n=e.findBone(o),n==null))throw new Error(`Parent bone not found: ${o}`);const l=new $e(e.bones.length,c.name,n);l.length=A(c,"length",0)*s,l.x=A(c,"x",0)*s,l.y=A(c,"y",0)*s,l.rotation=A(c,"rotation",0),l.scaleX=A(c,"scaleX",1),l.scaleY=A(c,"scaleY",1),l.shearX=A(c,"shearX",0),l.shearY=A(c,"shearY",0),l.transformMode=R.enumValue(nt,A(c,"transform","Normal")),l.skinRequired=A(c,"skin",!1);const d=A(c,"color",null);d&&l.color.setFromString(d),e.bones.push(l)}if(i.slots)for(let u=0;u<i.slots.length;u++){const c=i.slots[u],n=e.findBone(c.bone);if(!n)throw new Error(`Couldn't find bone ${c.bone} for slot ${c.name}`);const o=new Ge(e.slots.length,c.name,n),l=A(c,"color",null);l&&o.color.setFromString(l);const d=A(c,"dark",null);d&&(o.darkColor=D.fromString(d)),o.attachmentName=A(c,"attachment",null),o.blendMode=ae.blendModeFromString(A(c,"blend","normal")),e.slots.push(o)}if(i.ik)for(let u=0;u<i.ik.length;u++){const c=i.ik[u],n=new qe(c.name);n.order=A(c,"order",0),n.skinRequired=A(c,"skin",!1);for(let o=0;o<c.bones.length;o++){const l=c.bones[o],d=e.findBone(l);if(d==null)throw new Error(`IK bone not found: ${l}`);n.bones.push(d)}n.target=e.findBone(c.target),n.mix=A(c,"mix",1),n.softness=A(c,"softness",0)*s,n.bendDirection=A(c,"bendPositive",!0)?1:-1,n.compress=A(c,"compress",!1),n.stretch=A(c,"stretch",!1),n.uniform=A(c,"uniform",!1),e.ikConstraints.push(n)}if(i.transform)for(let u=0;u<i.transform.length;u++){const c=i.transform[u],n=new Ke(c.name);n.order=A(c,"order",0),n.skinRequired=A(c,"skin",!1);for(let d=0;d<c.bones.length;d++){const h=c.bones[d],m=e.findBone(h);if(!m)throw new Error(`Couldn't find bone ${h} for transform constraint ${c.name}.`);n.bones.push(m)}const o=c.target,l=e.findBone(o);if(!l)throw new Error(`Couldn't find target bone ${o} for transform constraint ${c.name}.`);n.target=l,n.local=A(c,"local",!1),n.relative=A(c,"relative",!1),n.offsetRotation=A(c,"rotation",0),n.offsetX=A(c,"x",0)*s,n.offsetY=A(c,"y",0)*s,n.offsetScaleX=A(c,"scaleX",0),n.offsetScaleY=A(c,"scaleY",0),n.offsetShearY=A(c,"shearY",0),n.mixRotate=A(c,"mixRotate",1),n.mixX=A(c,"mixX",1),n.mixY=A(c,"mixY",n.mixX),n.mixScaleX=A(c,"mixScaleX",1),n.mixScaleY=A(c,"mixScaleY",n.mixScaleX),n.mixShearY=A(c,"mixShearY",1),e.transformConstraints.push(n)}if(i.path)for(let u=0;u<i.path.length;u++){const c=i.path[u],n=new Ue(c.name);n.order=A(c,"order",0),n.skinRequired=A(c,"skin",!1);for(let d=0;d<c.bones.length;d++){const h=c.bones[d],m=e.findBone(h);if(!m)throw new Error(`Couldn't find bone ${h} for path constraint ${c.name}.`);n.bones.push(m)}const o=c.target,l=e.findSlot(o);if(!l)throw new Error(`Couldn't find target slot ${o} for path constraint ${c.name}.`);n.target=l,n.positionMode=R.enumValue(gt,A(c,"positionMode","Percent")),n.spacingMode=R.enumValue(j,A(c,"spacingMode","Length")),n.rotateMode=R.enumValue(Yt,A(c,"rotateMode","Tangent")),n.offsetRotation=A(c,"rotation",0),n.position=A(c,"position",0),n.positionMode==gt.Fixed&&(n.position*=s),n.spacing=A(c,"spacing",0),(n.spacingMode==j.Length||n.spacingMode==j.Fixed)&&(n.spacing*=s),n.mixRotate=A(c,"mixRotate",1),n.mixX=A(c,"mixX",1),n.mixY=A(c,"mixY",n.mixX),e.pathConstraints.push(n)}if(i.skins)for(let u=0;u<i.skins.length;u++){const c=i.skins[u],n=new re(c.name);if(c.bones)for(let o=0;o<c.bones.length;o++){const l=c.bones[o],d=e.findBone(l);if(!d)throw new Error(`Couldn't find bone ${l} for skin ${c.name}.`);n.bones.push(d)}if(c.ik)for(let o=0;o<c.ik.length;o++){const l=c.ik[o],d=e.findIkConstraint(l);if(!d)throw new Error(`Couldn't find IK constraint ${l} for skin ${c.name}.`);n.constraints.push(d)}if(c.transform)for(let o=0;o<c.transform.length;o++){const l=c.transform[o],d=e.findTransformConstraint(l);if(!d)throw new Error(`Couldn't find transform constraint ${l} for skin ${c.name}.`);n.constraints.push(d)}if(c.path)for(let o=0;o<c.path.length;o++){const l=c.path[o],d=e.findPathConstraint(l);if(!d)throw new Error(`Couldn't find path constraint ${l} for skin ${c.name}.`);n.constraints.push(d)}for(const o in c.attachments){const l=e.findSlot(o);if(!l)throw new Error(`Couldn't find slot ${o} for skin ${c.name}.`);const d=c.attachments[o];for(const h in d){const m=this.readAttachment(d[h],n,l.index,h,e);m&&n.setAttachment(l.index,h,m)}}e.skins.push(n),n.name=="default"&&(e.defaultSkin=n)}for(let u=0,c=this.linkedMeshes.length;u<c;u++){const n=this.linkedMeshes[u],o=n.skin?e.findSkin(n.skin):e.defaultSkin;if(!o)throw new Error(`Skin not found: ${n.skin}`);const l=o.getAttachment(n.slotIndex,n.parent);if(!l)throw new Error(`Parent mesh not found: ${n.parent}`);n.mesh.timelineAttachment=n.inheritTimeline?l:n.mesh,n.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,i.events)for(const u in i.events){const c=i.events[u],n=new We(u);n.intValue=A(c,"int",0),n.floatValue=A(c,"float",0),n.stringValue=A(c,"string",""),n.audioPath=A(c,"audio",null),n.audioPath&&(n.volume=A(c,"volume",1),n.balance=A(c,"balance",0)),e.events.push(n)}if(i.animations)for(const u in i.animations){const c=i.animations[u];this.readAnimation(c,u,e)}return e}readAttachment(t,s,e,i,a){const u=this.scale;switch(i=A(t,"name",i),A(t,"type","region")){case"region":{const c=A(t,"path",i),n=this.readSequence(A(t,"sequence",null)),o=this.attachmentLoader.newRegionAttachment(s,i,c,n);if(!o)return null;o.path=c,o.x=A(t,"x",0)*u,o.y=A(t,"y",0)*u,o.scaleX=A(t,"scaleX",1),o.scaleY=A(t,"scaleY",1),o.rotation=A(t,"rotation",0),o.width=t.width*u,o.height=t.height*u,o.sequence=n;const l=A(t,"color",null);return l&&o.color.setFromString(l),o}case"boundingbox":{const c=this.attachmentLoader.newBoundingBoxAttachment(s,i);if(!c)return null;this.readVertices(t,c,t.vertexCount<<1);const n=A(t,"color",null);return n&&c.color.setFromString(n),c}case"mesh":case"linkedmesh":{const c=A(t,"path",i),n=this.readSequence(A(t,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(s,i,c,n);if(!o)return null;o.path=c;const l=A(t,"color",null);l&&o.color.setFromString(l),o.width=A(t,"width",0)*u,o.height=A(t,"height",0)*u,o.sequence=n;const d=A(t,"parent",null);if(d)return this.linkedMeshes.push(new bn(o,A(t,"skin",null),e,d,A(t,"timelines",!0))),o;const h=t.uvs;return this.readVertices(t,o,h.length),o.triangles=t.triangles,o.regionUVs=new Float32Array(h),o.edges=A(t,"edges",null),o.hullLength=A(t,"hull",0)*2,o}case"path":{const c=this.attachmentLoader.newPathAttachment(s,i);if(!c)return null;c.closed=A(t,"closed",!1),c.constantSpeed=A(t,"constantSpeed",!0);const n=t.vertexCount;this.readVertices(t,c,n<<1);const o=R.newArray(n/3,0);for(let d=0;d<t.lengths.length;d++)o[d]=t.lengths[d]*u;c.lengths=o;const l=A(t,"color",null);return l&&c.color.setFromString(l),c}case"point":{const c=this.attachmentLoader.newPointAttachment(s,i);if(!c)return null;c.x=A(t,"x",0)*u,c.y=A(t,"y",0)*u,c.rotation=A(t,"rotation",0);const n=A(t,"color",null);return n&&c.color.setFromString(n),c}case"clipping":{const c=this.attachmentLoader.newClippingAttachment(s,i);if(!c)return null;const n=A(t,"end",null);if(n!=null){const d=a.findSlot(n);if(d==null)throw new Error(`Clipping end slot not found: ${n}`);c.endSlot=d}const o=t.vertexCount;this.readVertices(t,c,o<<1);const l=A(t,"color",null);return l&&c.color.setFromString(l),c}}return null}readSequence(t){if(t==null)return null;const s=new te(A(t,"count",0));return s.start=A(t,"start",1),s.digits=A(t,"digits",0),s.setupIndex=A(t,"setup",0),s}readVertices(t,s,e){const i=this.scale;s.worldVerticesLength=e;const a=t.vertices;if(e==a.length){const n=R.toFloatArray(a);if(i!=1)for(let o=0,l=a.length;o<l;o++)n[o]*=i;s.vertices=n;return}const u=new Array,c=new Array;for(let n=0,o=a.length;n<o;){const l=a[n++];c.push(l);for(let d=n+l*4;n<d;n+=4)c.push(a[n]),u.push(a[n+1]*i),u.push(a[n+2]*i),u.push(a[n+3])}s.bones=c,s.vertices=R.toFloatArray(u)}readAnimation(t,s,e){const i=this.scale,a=new Array;if(t.slots)for(const c in t.slots){const n=t.slots[c],o=e.findSlot(c);if(!o)throw new Error(`Slot not found: ${c}`);const l=o.index;for(const d in n){const h=n[d];if(!h)continue;const m=h.length;if(d=="attachment"){const f=new Xt(m,l);for(let g=0;g<m;g++){const w=h[g];f.setFrame(g,A(w,"time",0),A(w,"name",null))}a.push(f)}else if(d=="rgba"){const f=new Te(m,m<<2,l);let g=h[0],w=A(g,"time",0),S=D.fromString(g.color);for(let p=0,b=0;;p++){f.setFrame(p,w,S.r,S.g,S.b,S.a);const x=h[p+1];if(!x){f.shrink(b);break}const y=A(x,"time",0),k=D.fromString(x.color),C=g.curve;C&&(b=U(C,f,b,p,0,w,y,S.r,k.r,1),b=U(C,f,b,p,1,w,y,S.g,k.g,1),b=U(C,f,b,p,2,w,y,S.b,k.b,1),b=U(C,f,b,p,3,w,y,S.a,k.a,1)),w=y,S=k,g=x}a.push(f)}else if(d=="rgb"){const f=new Ie(m,m*3,l);let g=h[0],w=A(g,"time",0),S=D.fromString(g.color);for(let p=0,b=0;;p++){f.setFrame(p,w,S.r,S.g,S.b);const x=h[p+1];if(!x){f.shrink(b);break}const y=A(x,"time",0),k=D.fromString(x.color),C=g.curve;C&&(b=U(C,f,b,p,0,w,y,S.r,k.r,1),b=U(C,f,b,p,1,w,y,S.g,k.g,1),b=U(C,f,b,p,2,w,y,S.b,k.b,1)),w=y,S=k,g=x}a.push(f)}else if(d=="alpha")a.push(wt(h,new Ye(m,m,l),0,1));else if(d=="rgba2"){const f=new Ee(m,m*7,l);let g=h[0],w=A(g,"time",0),S=D.fromString(g.light),p=D.fromString(g.dark);for(let b=0,x=0;;b++){f.setFrame(b,w,S.r,S.g,S.b,S.a,p.r,p.g,p.b);const y=h[b+1];if(!y){f.shrink(x);break}const k=A(y,"time",0),C=D.fromString(y.light),T=D.fromString(y.dark),M=g.curve;M&&(x=U(M,f,x,b,0,w,k,S.r,C.r,1),x=U(M,f,x,b,1,w,k,S.g,C.g,1),x=U(M,f,x,b,2,w,k,S.b,C.b,1),x=U(M,f,x,b,3,w,k,S.a,C.a,1),x=U(M,f,x,b,4,w,k,p.r,T.r,1),x=U(M,f,x,b,5,w,k,p.g,T.g,1),x=U(M,f,x,b,6,w,k,p.b,T.b,1)),w=k,S=C,p=T,g=y}a.push(f)}else if(d=="rgb2"){const f=new Fe(m,m*6,l);let g=h[0],w=A(g,"time",0),S=D.fromString(g.light),p=D.fromString(g.dark);for(let b=0,x=0;;b++){f.setFrame(b,w,S.r,S.g,S.b,p.r,p.g,p.b);const y=h[b+1];if(!y){f.shrink(x);break}const k=A(y,"time",0),C=D.fromString(y.light),T=D.fromString(y.dark),M=g.curve;M&&(x=U(M,f,x,b,0,w,k,S.r,C.r,1),x=U(M,f,x,b,1,w,k,S.g,C.g,1),x=U(M,f,x,b,2,w,k,S.b,C.b,1),x=U(M,f,x,b,3,w,k,p.r,T.r,1),x=U(M,f,x,b,4,w,k,p.g,T.g,1),x=U(M,f,x,b,5,w,k,p.b,T.b,1)),w=k,S=C,p=T,g=y}a.push(f)}}}if(t.bones)for(const c in t.bones){const n=t.bones[c],o=e.findBone(c);if(!o)throw new Error(`Bone not found: ${c}`);const l=o.index;for(const d in n){const h=n[d],m=h.length;if(m!=0){if(d==="rotate")a.push(wt(h,new Ot(m,m,l),0,1));else if(d==="translate"){const f=new we(m,m<<1,l);a.push(je(h,f,"x","y",0,i))}else if(d==="translatex"){const f=new be(m,m,l);a.push(wt(h,f,0,i))}else if(d==="translatey"){const f=new ye(m,m,l);a.push(wt(h,f,0,i))}else if(d==="scale"){const f=new Se(m,m<<1,l);a.push(je(h,f,"x","y",1,1))}else if(d==="scalex"){const f=new ke(m,m,l);a.push(wt(h,f,1,1))}else if(d==="scaley"){const f=new Ce(m,m,l);a.push(wt(h,f,1,1))}else if(d==="shear"){const f=new Ae(m,m<<1,l);a.push(je(h,f,"x","y",0,1))}else if(d==="shearx"){const f=new ve(m,m,l);a.push(wt(h,f,0,1))}else if(d==="sheary"){const f=new Me(m,m,l);a.push(wt(h,f,0,1))}}}}if(t.ik)for(const c in t.ik){const n=t.ik[c];let o=n[0];if(!o)continue;const l=e.findIkConstraint(c);if(!l)throw new Error(`IK Constraint not found: ${c}`);const d=e.ikConstraints.indexOf(l),h=new Xe(n.length,n.length<<1,d);let m=A(o,"time",0),f=A(o,"mix",1),g=A(o,"softness",0)*i;for(let w=0,S=0;;w++){h.setFrame(w,m,f,g,A(o,"bendPositive",!0)?1:-1,A(o,"compress",!1),A(o,"stretch",!1));const p=n[w+1];if(!p){h.shrink(S);break}const b=A(p,"time",0),x=A(p,"mix",1),y=A(p,"softness",0)*i,k=o.curve;k&&(S=U(k,h,S,w,0,m,b,f,x,1),S=U(k,h,S,w,1,m,b,g,y,i)),m=b,f=x,g=y,o=p}a.push(h)}if(t.transform)for(const c in t.transform){const n=t.transform[c];let o=n[0];if(!o)continue;const l=e.findTransformConstraint(c);if(!l)throw new Error(`Transform constraint not found: ${c}`);const d=e.transformConstraints.indexOf(l),h=new Re(n.length,n.length*6,d);let m=A(o,"time",0),f=A(o,"mixRotate",1),g=A(o,"mixX",1),w=A(o,"mixY",g),S=A(o,"mixScaleX",1),p=A(o,"mixScaleY",S);const b=A(o,"mixShearY",1);for(let x=0,y=0;;x++){h.setFrame(x,m,f,g,w,S,p,b);const k=n[x+1];if(!k){h.shrink(y);break}const C=A(k,"time",0),T=A(k,"mixRotate",1),M=A(k,"mixX",1),Y=A(k,"mixY",M),I=A(k,"mixScaleX",1),B=A(k,"mixScaleY",I),X=A(k,"mixShearY",1),P=o.curve;P&&(y=U(P,h,y,x,0,m,C,f,T,1),y=U(P,h,y,x,1,m,C,g,M,1),y=U(P,h,y,x,2,m,C,w,Y,1),y=U(P,h,y,x,3,m,C,S,I,1),y=U(P,h,y,x,4,m,C,p,B,1),y=U(P,h,y,x,5,m,C,b,X,1)),m=C,f=T,g=M,w=Y,S=I,p=B,S=I,o=k}a.push(h)}if(t.path)for(const c in t.path){const n=t.path[c],o=e.findPathConstraint(c);if(!o)throw new Error(`Path constraint not found: ${c}`);const l=e.pathConstraints.indexOf(o);for(const d in n){const h=n[d];let m=h[0];if(!m)continue;const f=h.length;if(d==="position"){const g=new Pe(f,f,l);a.push(wt(h,g,0,o.positionMode==gt.Fixed?i:1))}else if(d==="spacing"){const g=new Le(f,f,l);a.push(wt(h,g,0,o.spacingMode==j.Length||o.spacingMode==j.Fixed?i:1))}else if(d==="mix"){const g=new De(f,f*3,l);let w=A(m,"time",0),S=A(m,"mixRotate",1),p=A(m,"mixX",1),b=A(m,"mixY",p);for(let x=0,y=0;;x++){g.setFrame(x,w,S,p,b);const k=h[x+1];if(!k){g.shrink(y);break}const C=A(k,"time",0),T=A(k,"mixRotate",1),M=A(k,"mixX",1),Y=A(k,"mixY",M),I=m.curve;I&&(y=U(I,g,y,x,0,w,C,S,T,1),y=U(I,g,y,x,1,w,C,p,M,1),y=U(I,g,y,x,2,w,C,b,Y,1)),w=C,S=T,p=M,b=Y,m=k}a.push(g)}}}if(t.deform){t.attachments={};for(const c in t.deform){const n=t.deform[c],o=t.attachments[c]={};for(const l in n){const d=n[l],h=o[l]={};for(const m in d)h[m]={deform:d[m]}}}}if(t.attachments)for(const c in t.attachments){const n=t.attachments[c],o=e.findSkin(c);if(o==null){if(Mt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${c}`);continue}for(const l in n){const d=n[l],h=e.findSlot(l);if(!h)throw new Error(`Slot not found: ${l}`);const m=h.index;for(const f in d){const g=d[f],w=o.getAttachment(m,f);for(const S in g){const p=g[S];let b=p[0];if(b){if(S=="deform"){const x=w.bones,y=w.vertices,k=x?y.length/3*2:y.length,C=new Be(p.length,p.length,m,w);let T=A(b,"time",0);for(let M=0,Y=0;;M++){let I;const B=A(b,"vertices",null);if(!B)I=x?R.newFloatArray(k):y;else{I=R.newFloatArray(k);const N=A(b,"offset",0);if(R.arrayCopy(B,0,I,N,B.length),i!=1)for(let L=N,z=L+B.length;L<z;L++)I[L]*=i;if(!x)for(let L=0;L<k;L++)I[L]+=y[L]}C.setFrame(M,T,I);const X=p[M+1];if(!X){C.shrink(Y);break}const P=A(X,"time",0),O=b.curve;O&&(Y=U(O,C,Y,M,0,T,P,0,1,1)),T=P,b=X}a.push(C)}else if(S=="sequence"){const x=new Dt(p.length,m,w);let y=0;for(let k=0;k<p.length;k++){const C=A(b,"delay",y),T=A(b,"time",0),M=xt[A(b,"mode","hold")],Y=A(b,"index",0);x.setFrame(k,T,M,Y,C),y=C,b=p[k+1]}a.push(x)}}}}}}if(t.drawOrder){const c=new Rt(t.drawOrder.length),n=e.slots.length;let o=0;for(let l=0;l<t.drawOrder.length;l++,o++){const d=t.drawOrder[l];let h=null;const m=A(d,"offsets",null);if(m){h=R.newArray(n,-1);const f=R.newArray(n-m.length,0);let g=0,w=0;for(let S=0;S<m.length;S++){const p=m[S],b=e.findSlot(p.slot);if(!b)throw new Error(`Slot not found: ${b}`);const x=b.index;for(;g!=x;)f[w++]=g++;h[g+p.offset]=g++}for(;g<n;)f[w++]=g++;for(let S=n-1;S>=0;S--)h[S]==-1&&(h[S]=f[--w])}c.setFrame(o,A(d,"time",0),h)}a.push(c)}if(t.events){const c=new Wt(t.events.length);let n=0;for(let o=0;o<t.events.length;o++,n++){const l=t.events[o],d=e.findEvent(l.name);if(!d)throw new Error(`Event not found: ${l.name}`);const h=new Oe(R.toSinglePrecision(A(l,"time",0)),d);h.intValue=A(l,"int",d.intValue),h.floatValue=A(l,"float",d.floatValue),h.stringValue=A(l,"string",d.stringValue),h.data.audioPath&&(h.volume=A(l,"volume",1),h.balance=A(l,"balance",0)),c.setFrame(n,h)}a.push(c)}let u=0;for(let c=0,n=a.length;c<n;c++)u=Math.max(u,a[c].getDuration());if(isNaN(u))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new ee(s,a,u))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class bn{constructor(t,s,e,i,a){this.mesh=t,this.skin=s,this.slotIndex=e,this.parent=i,this.inheritTimeline=a}}function wt(r,t,s,e){let i=r[0],a=A(i,"time",0),u=A(i,"value",s)*e,c=0;for(let n=0;;n++){t.setFrame(n,a,u);const o=r[n+1];if(!o)return t.shrink(c),t;const l=A(o,"time",0),d=A(o,"value",s)*e;i.curve&&(c=U(i.curve,t,c,n,0,a,l,u,d,e)),a=l,u=d,i=o}}function je(r,t,s,e,i,a){let u=r[0],c=A(u,"time",0),n=A(u,s,i)*a,o=A(u,e,i)*a,l=0;for(let d=0;;d++){t.setFrame(d,c,n,o);const h=r[d+1];if(!h)return t.shrink(l),t;const m=A(h,"time",0),f=A(h,s,i)*a,g=A(h,e,i)*a,w=u.curve;w&&(l=U(w,t,l,d,0,c,m,n,f,a),l=U(w,t,l,d,1,c,m,o,g,a)),c=m,n=f,o=g,u=h}}function U(r,t,s,e,i,a,u,c,n,o){if(r=="stepped")return t.setStepped(e),s;const l=i<<2,d=r[l],h=r[l+1]*o,m=r[l+2],f=r[l+3]*o;return t.setBezier(s,e,i,a,c,d,h,m,f,u,n),s+1}function A(r,t,s){return r[t]!==void 0?r[t]:s}class yn extends Kt{createSkeleton(t){this.skeleton=new ze(t),this.skeleton.updateWorldTransform(),this.stateData=new ws(t),this.state=new Nt(this.stateData)}}class Sn extends Us{createBinaryParser(){return new Qe(null)}createJsonParser(){return new ae(null)}parseData(t,s,e){const i=t;return i.attachmentLoader=new bs(s),{spineData:i.readSkeletonData(e),spineAtlas:s}}}return new Sn().installLoader(),F.AlphaTimeline=Ye,F.Animation=ee,F.AnimationState=Nt,F.AnimationStateAdapter=zs,F.AnimationStateData=ws,F.AtlasAttachmentLoader=bs,F.Attachment=xe,F.AttachmentTimeline=Xt,F.AttachmentType=Q,F.BinaryInput=ss,F.Bone=_e,F.BoneData=$e,F.BoundingBoxAttachment=Jt,F.ClippingAttachment=Qt,F.Color=D,F.ConstraintData=ie,F.CurveTimeline=ht,F.CurveTimeline1=dt,F.CurveTimeline2=se,F.DebugUtils=Vs,F.DeformTimeline=Be,F.DrawOrderTimeline=Rt,F.Event=Oe,F.EventData=We,F.EventQueue=ms,F.EventTimeline=Wt,F.EventType=it,F.IkConstraint=ys,F.IkConstraintData=qe,F.IkConstraintTimeline=Xe,F.IntSet=Ds,F.Interpolation=ns,F.MathUtils=E,F.MeshAttachment=Ft,F.MixBlend=v,F.MixDirection=et,F.PathAttachment=Bt,F.PathConstraint=Vt,F.PathConstraintData=Ue,F.PathConstraintMixTimeline=De,F.PathConstraintPositionTimeline=Pe,F.PathConstraintSpacingTimeline=Le,F.PointAttachment=Zt,F.Pool=me,F.PositionMode=gt,F.Pow=is,F.PowOut=Ns,F.RGB2Timeline=Fe,F.RGBA2Timeline=Ee,F.RGBATimeline=Te,F.RGBTimeline=Ie,F.RegionAttachment=q,F.RotateMode=Yt,F.RotateTimeline=Ot,F.ScaleTimeline=Se,F.ScaleXTimeline=ke,F.ScaleYTimeline=Ce,F.Sequence=te,F.SequenceMode=xt,F.SequenceModeValues=pe,F.SequenceTimeline=Dt,F.ShearTimeline=Ae,F.ShearXTimeline=ve,F.ShearYTimeline=Me,F.Skeleton=ze,F.SkeletonBinary=Qe,F.SkeletonBounds=wn,F.SkeletonBoundsBase=ge,F.SkeletonData=He,F.SkeletonJson=ae,F.Skin=re,F.SkinEntry=Je,F.Slot=Ss,F.SlotData=Ge,F.SpacingMode=j,F.Spine=yn,F.SpineBase=Kt,F.SpineDebugRenderer=Os,F.SpineMesh=as,F.SpineSprite=rs,F.StringSet=fe,F.TextureAtlas=Ht,F.TextureAtlasPage=de,F.TextureAtlasRegion=ue,F.TextureFilter=st,F.TextureRegion=zt,F.TextureWrap=lt,F.TimeKeeper=_s,F.Timeline=Z,F.TrackEntry=ne,F.TransformConstraint=ks,F.TransformConstraintData=Ke,F.TransformConstraintTimeline=Re,F.TransformMode=nt,F.TranslateTimeline=we,F.TranslateXTimeline=be,F.TranslateYTimeline=ye,F.Utils=R,F.Vector2=Gt,F.VertexAttachment=ct,F.WindowedMean=$s,F.filterFromString=he,F.settings=Mt,F.wrapFromString=Rs,F}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=pixi-spine-4.1.js.map
